From 2a9778d167957b41aaee18260a289462f2485913 Mon Sep 17 00:00:00 2001
From: yanavlasov <yavlasov@google.com>
Date: Tue, 30 Jul 2019 09:43:18 -0400
Subject: [PATCH 1/6] http2: Limit the number of outbound frames (#9)

Limit the number of outbound (these, waiting to be written into the socket)
HTTP/2 frames. When the limit is exceeded the connection is terminated.

This mitigates flood exploits where a client continually sends frames that
are not subject to flow control without reading server responses.

Fixes CVE-2019-9512, CVE-2019-9514 and CVE-2019-9515.

Signed-off-by: Yan Avlasov <yavlasov@google.com>
---
 api/envoy/api/v2/core/protocol.proto            |  15 ++
 docs/root/configuration/http_conn_man/stats.rst |   2 +
 docs/root/intro/version_history.rst             |   6 +
 include/envoy/buffer/buffer.h                   |   4 +-
 include/envoy/http/codec.h                      |   7 +
 source/common/buffer/buffer_impl.h              |  44 ++++-
 source/common/http/conn_manager_impl.cc         |  28 +++-
 source/common/http/conn_manager_impl.h          |   1 +
 source/common/http/exception.h                  |   8 +
 source/common/http/http2/codec_impl.cc          | 122 +++++++++++++-
 source/common/http/http2/codec_impl.h           |  78 ++++++++-
 source/common/http/utility.cc                   |   5 +
 source/common/network/connection_impl.h         |   2 +
 test/common/buffer/buffer_test.cc               |  16 ++
 test/common/buffer/owned_impl_test.cc           |  51 ++++++
 test/common/http/conn_manager_impl_test.cc      |  21 +++
 test/common/http/http2/BUILD                    |  10 ++
 test/common/http/http2/codec_impl_test.cc       | 210 ++++++++++++++++++++++++
 test/common/http/http2/codec_impl_test_util.h   |   1 +
 test/common/http/http2/http2_frame.cc           | 148 +++++++++++++++++
 test/common/http/http2/http2_frame.h            | 126 ++++++++++++++
 test/common/http/utility_test.cc                |   3 +
 test/config/utility.cc                          |  15 ++
 test/config/utility.h                           |   3 +
 test/integration/BUILD                          |   1 +
 test/integration/http2_integration_test.cc      | 158 ++++++++++++++++++
 test/integration/http2_integration_test.h       |  20 +++
 test/integration/integration.cc                 |   9 +
 test/integration/integration.h                  |   5 +-
 test/integration/tcp_proxy_integration_test.cc  |   9 +
 test/integration/utility.cc                     |   5 +
 test/integration/utility.h                      |   9 +-
 test/test_common/utility.cc                     |   2 +
 33 files changed, 1123 insertions(+), 21 deletions(-)
 create mode 100644 test/common/http/http2/http2_frame.cc
 create mode 100644 test/common/http/http2/http2_frame.h

diff --git a/api/envoy/api/v2/core/protocol.proto b/api/envoy/api/v2/core/protocol.proto
index 200b8517ab..becd596a0e 100644
--- a/api/envoy/api/v2/core/protocol.proto
+++ b/api/envoy/api/v2/core/protocol.proto
@@ -91,6 +91,21 @@ message Http2ProtocolOptions {
   // docs](https://github.com/envoyproxy/envoy/blob/master/source/docs/h2_metadata.md) for more
   // information.
   bool allow_metadata = 6;
+
+  // Limit the number of pending outbound downstream frames of all types (frames that are waiting to
+  // be written into the socket). Exceeding this limit triggers flood mitigation and connection is
+  // terminated. The "http2.outbound_flood" stat tracks the number of terminated connections due to
+  // flood mitigation. The default limit is 10000.
+  // [#comment:TODO: implement same limits for upstream outbound frames as well.]
+  google.protobuf.UInt32Value max_outbound_frames = 7 [(validate.rules).uint32 = {gte: 1}];
+
+  // Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
+  // preventing high memory utilization when receiving continuous stream of these frames. Exceeding
+  // this limit triggers flood mitigation and connection is terminated. The
+  // "http2.outbound_control_flood" stat tracks the number of terminated connections due to flood
+  // mitigation. The default limit is 1000.
+  // [#comment:TODO: implement same limits for upstream outbound frames as well.]
+  google.protobuf.UInt32Value max_outbound_control_frames = 8 [(validate.rules).uint32 = {gte: 1}];
 }
 
 // [#not-implemented-hide:]
diff --git a/docs/root/configuration/http_conn_man/stats.rst b/docs/root/configuration/http_conn_man/stats.rst
index 0269fefc1d..3c5a0cdae1 100644
--- a/docs/root/configuration/http_conn_man/stats.rst
+++ b/docs/root/configuration/http_conn_man/stats.rst
@@ -111,6 +111,8 @@ All http2 statistics are rooted at *http2.*
 
    header_overflow, Counter, Total number of connections reset due to the headers being larger than the :ref:`configured value <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.max_request_headers_kb>`.
    headers_cb_no_stream, Counter, Total number of errors where a header callback is called without an associated stream. This tracks an unexpected occurrence due to an as yet undiagnosed bug
+   outbound_flood, Counter, Total number of connections terminated for exceeding the limit on outbound frames of all types. The limit is configured by setting the :ref:`max_outbound_frames config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_frames>`.
+   outbound_control_flood, Counter, "Total number of connections terminated for exceeding the limit on outbound frames of types PING, SETTINGS and RST_STREAM. The limit is configured by setting the :ref:`max_outbound_control_frames config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_control_frames>`."
    rx_messaging_error, Counter, Total number of invalid received frames that violated `section 8 <https://tools.ietf.org/html/rfc7540#section-8>`_ of the HTTP/2 spec. This will result in a *tx_reset*
    rx_reset, Counter, Total number of reset stream frames received by Envoy
    too_many_header_frames, Counter, Total number of times an HTTP2 connection is reset due to receiving too many headers frames. Envoy currently supports proxying at most one header frame for 100-Continue one non-100 response code header frame and one frame with trailers
diff --git a/docs/root/intro/version_history.rst b/docs/root/intro/version_history.rst
index bcd2848341..223773dfe5 100644
--- a/docs/root/intro/version_history.rst
+++ b/docs/root/intro/version_history.rst
@@ -1,6 +1,12 @@
 Version history
 ---------------
 
+1.11.1 (Pending)
+================
+* http: added mitigation of client initiated atacks that result in flooding of the outbound queue of downstream HTTP/2 connections.
+* http: added :ref:`outbound_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for tracking number of connections terminated for exceeding the outbound queue limit. The limit is configured by setting the :ref:`max_outbound_frames config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_frames>`
+* http: added :ref:`outbound_control_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for tracking number of connections terminated for exceeding the outbound queue limit for PING, SETTINGS and RST_STREAM frames. The limit is configured by setting the :ref:`max_outbound_control_frames config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_control_frames>`.
+
 1.11.0 (July 11, 2019)
 ======================
 * access log: added a new field for downstream TLS session ID to file and gRPC access logger.
diff --git a/include/envoy/buffer/buffer.h b/include/envoy/buffer/buffer.h
index 1f19d94d66..468cf17fa9 100644
--- a/include/envoy/buffer/buffer.h
+++ b/include/envoy/buffer/buffer.h
@@ -33,6 +33,7 @@ struct RawSlice {
  */
 class BufferFragment {
 public:
+  virtual ~BufferFragment() = default;
   /**
    * @return const void* a pointer to the referenced data.
    */
@@ -47,9 +48,6 @@ public:
    * Called by a buffer when the referenced data is no longer needed.
    */
   virtual void done() PURE;
-
-protected:
-  virtual ~BufferFragment() = default;
 };
 
 /**
diff --git a/include/envoy/http/codec.h b/include/envoy/http/codec.h
index 4ac313f7d6..d05943c0f9 100644
--- a/include/envoy/http/codec.h
+++ b/include/envoy/http/codec.h
@@ -235,6 +235,8 @@ struct Http2Settings {
   uint32_t initial_connection_window_size_{DEFAULT_INITIAL_CONNECTION_WINDOW_SIZE};
   bool allow_connect_{DEFAULT_ALLOW_CONNECT};
   bool allow_metadata_{DEFAULT_ALLOW_METADATA};
+  uint32_t max_outbound_frames_{DEFAULT_MAX_OUTBOUND_FRAMES};
+  uint32_t max_outbound_control_frames_{DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES};
 
   // disable HPACK compression
   static const uint32_t MIN_HPACK_TABLE_SIZE = 0;
@@ -272,6 +274,11 @@ struct Http2Settings {
   static const bool DEFAULT_ALLOW_CONNECT = false;
   // By default Envoy does not allow METADATA support.
   static const bool DEFAULT_ALLOW_METADATA = false;
+
+  // Default limit on the number of outbound frames of all types.
+  static const uint32_t DEFAULT_MAX_OUTBOUND_FRAMES = 10000;
+  // Default limit on the number of outbound frames of types PING, SETTINGS and RST_STREAM.
+  static const uint32_t DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES = 1000;
 };
 
 /**
diff --git a/source/common/buffer/buffer_impl.h b/source/common/buffer/buffer_impl.h
index 9851686b4f..68b361c579 100644
--- a/source/common/buffer/buffer_impl.h
+++ b/source/common/buffer/buffer_impl.h
@@ -193,7 +193,8 @@ protected:
 
 using SlicePtr = std::unique_ptr<Slice>;
 
-class OwnedSlice : public Slice, public InlineStorage {
+// OwnedSlice can not be derived from as it has variable sized array as member.
+class OwnedSlice final : public Slice, public InlineStorage {
 public:
   /**
    * Create an empty OwnedSlice.
@@ -563,5 +564,46 @@ private:
   Event::Libevent::BufferPtr buffer_;
 };
 
+using BufferFragmentPtr = std::unique_ptr<BufferFragment>;
+
+/**
+ * An implementation of BufferFragment where a releasor callback is called when the data is
+ * no longer needed. Copies data into internal buffer.
+ */
+class OwnedBufferFragmentImpl final : public BufferFragment, public InlineStorage {
+public:
+  using Releasor = std::function<void(const OwnedBufferFragmentImpl*)>;
+
+  /**
+   * Copies the data into internal buffer. The releasor is called when the data has been
+   * fully drained or the buffer that contains this fragment is destroyed.
+   * @param data external data to reference
+   * @param releasor a callback function to be called when data is no longer needed.
+   */
+
+  static BufferFragmentPtr create(absl::string_view data, const Releasor& releasor) {
+    return BufferFragmentPtr(new (sizeof(OwnedBufferFragmentImpl) + data.size())
+                                 OwnedBufferFragmentImpl(data, releasor));
+  }
+
+  // Buffer::BufferFragment
+  const void* data() const override { return data_; }
+  size_t size() const override { return size_; }
+  void done() override { releasor_(this); }
+
+private:
+  OwnedBufferFragmentImpl(absl::string_view data, const Releasor& releasor)
+      : releasor_(releasor), size_(data.size()) {
+    ASSERT(releasor != nullptr);
+    memcpy(data_, data.data(), data.size());
+  }
+
+  const Releasor releasor_;
+  const size_t size_;
+  uint8_t data_[];
+};
+
+using OwnedBufferFragmentImplPtr = std::unique_ptr<OwnedBufferFragmentImpl>;
+
 } // namespace Buffer
 } // namespace Envoy
diff --git a/source/common/http/conn_manager_impl.cc b/source/common/http/conn_manager_impl.cc
index 8e905ac5ab..bda3cde740 100644
--- a/source/common/http/conn_manager_impl.cc
+++ b/source/common/http/conn_manager_impl.cc
@@ -257,6 +257,19 @@ StreamDecoder& ConnectionManagerImpl::newStream(StreamEncoder& response_encoder,
   return **streams_.begin();
 }
 
+void ConnectionManagerImpl::handleCodecException(const char* error,
+                                                 Network::ConnectionCloseType close_type) {
+  ENVOY_CONN_LOG(debug, "dispatch error: {}", read_callbacks_->connection(), error);
+
+  // In the protocol error case, we need to reset all streams now. If the close_type is
+  // FlushWriteAndDelay, the connection might stick around long enough for a pending stream to come
+  // back and try to encode. In other cases it avoids needless processing of upstream responses when
+  // downstream connection is closed.
+  resetAllStreams();
+
+  read_callbacks_->connection().close(close_type);
+}
+
 Network::FilterStatus ConnectionManagerImpl::onData(Buffer::Instance& data, bool) {
   if (!codec_) {
     codec_ = config_.createCodec(read_callbacks_->connection(), data, *this);
@@ -275,18 +288,15 @@ Network::FilterStatus ConnectionManagerImpl::onData(Buffer::Instance& data, bool
 
     try {
       codec_->dispatch(data);
+    } catch (const FrameFloodException& e) {
+      // Abortively close flooded connections
+      handleCodecException(e.what(), Network::ConnectionCloseType::NoFlush);
+      return Network::FilterStatus::StopIteration;
     } catch (const CodecProtocolException& e) {
+      stats_.named_.downstream_cx_protocol_error_.inc();
       // HTTP/1.1 codec has already sent a 400 response if possible. HTTP/2 codec has already sent
       // GOAWAY.
-      ENVOY_CONN_LOG(debug, "dispatch error: {}", read_callbacks_->connection(), e.what());
-      stats_.named_.downstream_cx_protocol_error_.inc();
-
-      // In the protocol error case, we need to reset all streams now. Since we do a flush write and
-      // delayed close, the connection might stick around long enough for a pending stream to come
-      // back and try to encode.
-      resetAllStreams();
-
-      read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWriteAndDelay);
+      handleCodecException(e.what(), Network::ConnectionCloseType::FlushWriteAndDelay);
       return Network::FilterStatus::StopIteration;
     }
 
diff --git a/source/common/http/conn_manager_impl.h b/source/common/http/conn_manager_impl.h
index a7ef3ef9ea..cafef66310 100644
--- a/source/common/http/conn_manager_impl.h
+++ b/source/common/http/conn_manager_impl.h
@@ -582,6 +582,7 @@ private:
   void onDrainTimeout();
   void startDrainSequence();
   Tracing::HttpTracer& tracer() { return http_context_.tracer(); }
+  void handleCodecException(const char* error, Network::ConnectionCloseType close_type);
 
   enum class DrainState { NotDraining, Draining, Closing };
 
diff --git a/source/common/http/exception.h b/source/common/http/exception.h
index 445ef5fb14..1a7ef668b2 100644
--- a/source/common/http/exception.h
+++ b/source/common/http/exception.h
@@ -17,6 +17,14 @@ public:
 };
 
 /**
+ * Raised when outbound frame queue flood is detected.
+ */
+class FrameFloodException : public CodecProtocolException {
+public:
+  FrameFloodException(const std::string& message) : CodecProtocolException(message) {}
+};
+
+/**
  * Raised when a response is received on a connection that did not send a request. In practice
  * this can only happen on HTTP/1.1 connections.
  */
diff --git a/source/common/http/http2/codec_impl.cc b/source/common/http/http2/codec_impl.cc
index 475aa1d314..fe7518c19c 100644
--- a/source/common/http/http2/codec_impl.cc
+++ b/source/common/http/http2/codec_impl.cc
@@ -11,6 +11,7 @@
 #include "envoy/stats/scope.h"
 
 #include "common/common/assert.h"
+#include "common/common/cleanup.h"
 #include "common/common/enum_to_int.h"
 #include "common/common/fmt.h"
 #include "common/common/stack_array.h"
@@ -251,7 +252,13 @@ int ConnectionImpl::StreamImpl::onDataSourceSend(const uint8_t* framehd, size_t
   // https://nghttp2.org/documentation/types.html#c.nghttp2_send_data_callback
   static const uint64_t FRAME_HEADER_SIZE = 9;
 
-  Buffer::OwnedImpl output(framehd, FRAME_HEADER_SIZE);
+  Buffer::OwnedImpl output;
+  if (!parent_.addOutboundFrameFragment(output, framehd, FRAME_HEADER_SIZE)) {
+    ENVOY_CONN_LOG(debug, "error sending data frame: Too many frames in the outbound queue",
+                   parent_.connection_);
+    return NGHTTP2_ERR_FLOODED;
+  }
+
   output.move(pending_send_data_, length);
   parent_.connection_.write(output, false);
   return 0;
@@ -348,6 +355,10 @@ void ConnectionImpl::dispatch(Buffer::Instance& data) {
     dispatching_ = true;
     ssize_t rc =
         nghttp2_session_mem_recv(session_, static_cast<const uint8_t*>(slice.mem_), slice.len_);
+    if (rc == NGHTTP2_ERR_FLOODED) {
+      throw FrameFloodException(
+          "Flooding was detected in this HTTP/2 session, and it must be closed");
+    }
     if (rc != static_cast<ssize_t>(slice.len_)) {
       throw CodecProtocolException(fmt::format("{}", nghttp2_strerror(rc)));
     }
@@ -555,9 +566,77 @@ int ConnectionImpl::onInvalidFrame(int32_t stream_id, int error_code) {
   return NGHTTP2_ERR_CALLBACK_FAILURE;
 }
 
+int ConnectionImpl::onBeforeFrameSend(const nghttp2_frame* frame) {
+  ENVOY_CONN_LOG(trace, "about to sent frame type={}, flags={}", connection_,
+                 static_cast<uint64_t>(frame->hd.type), static_cast<uint64_t>(frame->hd.flags));
+  ASSERT(!is_outbound_flood_monitored_control_frame_);
+  // Flag flood monitored outbound control frames.
+  is_outbound_flood_monitored_control_frame_ =
+      ((frame->hd.type == NGHTTP2_PING || frame->hd.type == NGHTTP2_SETTINGS) &&
+       frame->hd.flags & NGHTTP2_FLAG_ACK) ||
+      frame->hd.type == NGHTTP2_RST_STREAM;
+  return 0;
+}
+
+void ConnectionImpl::incrementOutboundFrameCount(bool is_outbound_flood_monitored_control_frame) {
+  ++outbound_frames_;
+  if (is_outbound_flood_monitored_control_frame) {
+    ++outbound_control_frames_;
+  }
+  checkOutboundQueueLimits();
+}
+
+bool ConnectionImpl::addOutboundFrameFragment(Buffer::OwnedImpl& output, const uint8_t* data,
+                                              size_t length) {
+  // Reset the outbound frame type (set in the onBeforeFrameSend callback) since the
+  // onBeforeFrameSend callback is not called for DATA frames.
+  bool is_outbound_flood_monitored_control_frame = false;
+  std::swap(is_outbound_flood_monitored_control_frame, is_outbound_flood_monitored_control_frame_);
+  try {
+    incrementOutboundFrameCount(is_outbound_flood_monitored_control_frame);
+  } catch (const FrameFloodException&) {
+    return false;
+  }
+
+  auto fragment = Buffer::OwnedBufferFragmentImpl::create(
+      absl::string_view(reinterpret_cast<const char*>(data), length),
+      is_outbound_flood_monitored_control_frame ? control_frame_buffer_releasor_
+                                                : frame_buffer_releasor_);
+
+  // The Buffer::OwnedBufferFragmentImpl object will be deleted in the *frame_buffer_releasor_
+  // callback.
+  output.addBufferFragment(*fragment.release());
+  return true;
+}
+
+void ConnectionImpl::releaseOutboundFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {
+  ASSERT(outbound_frames_ >= 1);
+  --outbound_frames_;
+  delete fragment;
+}
+
+void ConnectionImpl::releaseOutboundControlFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {
+  ASSERT(outbound_control_frames_ >= 1);
+  --outbound_control_frames_;
+  releaseOutboundFrame(fragment);
+}
+
 ssize_t ConnectionImpl::onSend(const uint8_t* data, size_t length) {
   ENVOY_CONN_LOG(trace, "send data: bytes={}", connection_, length);
-  Buffer::OwnedImpl buffer(data, length);
+  Buffer::OwnedImpl buffer;
+  if (!addOutboundFrameFragment(buffer, data, length)) {
+    ENVOY_CONN_LOG(debug, "error sending frame: Too many frames in the outbound queue.",
+                   connection_);
+    return NGHTTP2_ERR_FLOODED;
+  }
+
+  // While the buffer is transient the fragment it contains will be moved into the
+  // write_buffer_ of the underlying connection_ by the write method below.
+  // This creates lifetime dependency between the write_buffer_ of the underlying connection
+  // and the codec object. Specifically the write_buffer_ MUST be either fully drained or
+  // deleted before the codec object is deleted. This is presently guaranteed by the
+  // destruction order of the Network::ConnectionImpl object where write_buffer_ is
+  // destroyed before the filter_manager_ which owns the codec through Http::ConnectionManagerImpl.
   connection_.write(buffer, false);
   return length;
 }
@@ -663,6 +742,15 @@ void ConnectionImpl::sendPendingFrames() {
   int rc = nghttp2_session_send(session_);
   if (rc != 0) {
     ASSERT(rc == NGHTTP2_ERR_CALLBACK_FAILURE);
+    // For errors caused by the pending outbound frame flood the FrameFloodException has
+    // to be thrown. However the nghttp2 library returns only the generic error code for
+    // all failure types. Check queue limits and throw FrameFloodException if they were
+    // exceeded.
+    if (outbound_frames_ > max_outbound_frames_ ||
+        outbound_control_frames_ > max_outbound_control_frames_) {
+      throw FrameFloodException("Too many frames in the outbound queue.");
+    }
+
     throw CodecProtocolException(fmt::format("{}", nghttp2_strerror(rc)));
   }
 
@@ -810,6 +898,11 @@ ConnectionImpl::Http2Callbacks::Http2Callbacks() {
         return static_cast<ConnectionImpl*>(user_data)->onFrameSend(frame);
       });
 
+  nghttp2_session_callbacks_set_before_frame_send_callback(
+      callbacks_, [](nghttp2_session*, const nghttp2_frame* frame, void* user_data) -> int {
+        return static_cast<ConnectionImpl*>(user_data)->onBeforeFrameSend(frame);
+      });
+
   nghttp2_session_callbacks_set_on_frame_not_send_callback(
       callbacks_, [](nghttp2_session*, const nghttp2_frame*, int, void*) -> int {
         // We used to always return failure here but it looks now this can get called if the other
@@ -979,6 +1072,31 @@ int ServerConnectionImpl::onHeader(const nghttp2_frame* frame, HeaderString&& na
   return saveHeader(frame, std::move(name), std::move(value));
 }
 
+void ServerConnectionImpl::checkOutboundQueueLimits() {
+  if (outbound_frames_ > max_outbound_frames_ && dispatching_downstream_data_) {
+    stats_.outbound_flood_.inc();
+    throw FrameFloodException("Too many frames in the outbound queue.");
+  }
+  if (outbound_control_frames_ > max_outbound_control_frames_ && dispatching_downstream_data_) {
+    stats_.outbound_control_flood_.inc();
+    throw FrameFloodException("Too many control frames in the outbound queue.");
+  }
+}
+
+void ServerConnectionImpl::dispatch(Buffer::Instance& data) {
+  ASSERT(!dispatching_downstream_data_);
+  dispatching_downstream_data_ = true;
+
+  // Make sure the dispatching_downstream_data_ is set to false even
+  // when ConnectionImpl::dispatch throws an exception.
+  Cleanup cleanup([this]() { dispatching_downstream_data_ = false; });
+
+  // Make sure downstream outbound queue was not flooded by the upstream frames.
+  checkOutboundQueueLimits();
+
+  ConnectionImpl::dispatch(data);
+}
+
 } // namespace Http2
 } // namespace Http
 } // namespace Envoy
diff --git a/source/common/http/http2/codec_impl.h b/source/common/http/http2/codec_impl.h
index 0b8c8bd0c4..a552ff461e 100644
--- a/source/common/http/http2/codec_impl.h
+++ b/source/common/http/http2/codec_impl.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include <cstdint>
+#include <functional>
 #include <list>
 #include <memory>
 #include <string>
@@ -37,16 +38,16 @@ const std::string CLIENT_MAGIC_PREFIX = "PRI * HTTP/2";
 /**
  * All stats for the HTTP/2 codec. @see stats_macros.h
  */
-// clang-format off
 #define ALL_HTTP2_CODEC_STATS(COUNTER)                                                             \
   COUNTER(header_overflow)                                                                         \
   COUNTER(headers_cb_no_stream)                                                                    \
+  COUNTER(outbound_control_flood)                                                                  \
+  COUNTER(outbound_flood)                                                                          \
   COUNTER(rx_messaging_error)                                                                      \
   COUNTER(rx_reset)                                                                                \
   COUNTER(too_many_header_frames)                                                                  \
   COUNTER(trailers)                                                                                \
   COUNTER(tx_reset)
-// clang-format on
 
 /**
  * Wrapper struct for the HTTP/2 codec stats. @see stats_macros.h
@@ -77,12 +78,21 @@ public:
                  const Http2Settings& http2_settings, const uint32_t max_request_headers_kb)
       : stats_{ALL_HTTP2_CODEC_STATS(POOL_COUNTER_PREFIX(stats, "http2."))},
         connection_(connection), max_request_headers_kb_(max_request_headers_kb),
-        per_stream_buffer_limit_(http2_settings.initial_stream_window_size_), dispatching_(false),
-        raised_goaway_(false), pending_deferred_reset_(false) {}
+        per_stream_buffer_limit_(http2_settings.initial_stream_window_size_),
+        max_outbound_frames_(http2_settings.max_outbound_frames_),
+        frame_buffer_releasor_([this](const Buffer::OwnedBufferFragmentImpl* fragment) {
+          releaseOutboundFrame(fragment);
+        }),
+        max_outbound_control_frames_(http2_settings.max_outbound_control_frames_),
+        control_frame_buffer_releasor_([this](const Buffer::OwnedBufferFragmentImpl* fragment) {
+          releaseOutboundControlFrame(fragment);
+        }),
+        dispatching_(false), raised_goaway_(false), pending_deferred_reset_(false) {}
 
   ~ConnectionImpl();
 
   // Http::Connection
+  // NOTE: the `dispatch` method is also overridden in the ServerConnectionImpl class
   void dispatch(Buffer::Instance& data) override;
   void goAway() override;
   Protocol protocol() override { return Protocol::Http2; }
@@ -290,20 +300,57 @@ protected:
   uint32_t per_stream_buffer_limit_;
   bool allow_metadata_;
 
+  // Set if the type of frame that is about to be sent is PING or SETTINGS with the ACK flag set, or
+  // RST_STREAM.
+  bool is_outbound_flood_monitored_control_frame_ = 0;
+  // This counter keeps track of the number of outbound frames of all types (these that were
+  // buffered in the underlying connection but not yet written into the socket). If this counter
+  // exceeds the `max_outbound_frames_' value the connection is terminated.
+  uint32_t outbound_frames_ = 0;
+  // Maximum number of outbound frames. Initialized from corresponding http2_protocol_options.
+  // Default value is 10000.
+  const uint32_t max_outbound_frames_;
+  const Buffer::OwnedBufferFragmentImpl::Releasor frame_buffer_releasor_;
+  // This counter keeps track of the number of outbound frames of types PING, SETTINGS and
+  // RST_STREAM (these that were buffered in the underlying connection but not yet written into the
+  // socket). If this counter exceeds the `max_outbound_control_frames_' value the connection is
+  // terminated.
+  uint32_t outbound_control_frames_ = 0;
+  // Maximum number of outbound frames of types PING, SETTINGS and RST_STREAM. Initialized from
+  // corresponding http2_protocol_options. Default value is 1000.
+  const uint32_t max_outbound_control_frames_;
+  const Buffer::OwnedBufferFragmentImpl::Releasor control_frame_buffer_releasor_;
+
 private:
   virtual ConnectionCallbacks& callbacks() PURE;
   virtual int onBeginHeaders(const nghttp2_frame* frame) PURE;
   int onData(int32_t stream_id, const uint8_t* data, size_t len);
   int onFrameReceived(const nghttp2_frame* frame);
+  int onBeforeFrameSend(const nghttp2_frame* frame);
   int onFrameSend(const nghttp2_frame* frame);
   virtual int onHeader(const nghttp2_frame* frame, HeaderString&& name, HeaderString&& value) PURE;
   int onInvalidFrame(int32_t stream_id, int error_code);
+
+  // For the flood mitigation to work the onSend callback must be called once for each outbound
+  // frame. This is what the nghttp2 library is doing, however this is not documented. The
+  // Http2FloodMitigationTest.* tests in test/integration/http2_integration_test.cc will break if
+  // this changes in the future. Also it is important that onSend does not do partial writes, as the
+  // nghttp2 library will keep calling this callback to write the rest of the frame.
   ssize_t onSend(const uint8_t* data, size_t length);
   int onStreamClose(int32_t stream_id, uint32_t error_code);
   int onMetadataReceived(int32_t stream_id, const uint8_t* data, size_t len);
   int onMetadataFrameComplete(int32_t stream_id, bool end_metadata);
   ssize_t packMetadata(int32_t stream_id, uint8_t* buf, size_t len);
 
+  // Adds buffer fragment for a new outbound frame to the supplied Buffer::OwnedImpl.
+  // Returns true on success or false if outbound queue limits were exceeded.
+  bool addOutboundFrameFragment(Buffer::OwnedImpl& output, const uint8_t* data, size_t length);
+  virtual void checkOutboundQueueLimits() PURE;
+  void incrementOutboundFrameCount(bool is_outbound_flood_monitored_control_frame);
+
+  void releaseOutboundFrame(const Buffer::OwnedBufferFragmentImpl* fragment);
+  void releaseOutboundControlFrame(const Buffer::OwnedBufferFragmentImpl* fragment);
+
   bool dispatching_ : 1;
   bool raised_goaway_ : 1;
   bool pending_deferred_reset_ : 1;
@@ -327,6 +374,15 @@ private:
   int onBeginHeaders(const nghttp2_frame* frame) override;
   int onHeader(const nghttp2_frame* frame, HeaderString&& name, HeaderString&& value) override;
 
+  // Presently client connections only perform accounting of outbound frames and do not
+  // terminate connections when queue limits are exceeded. The primary reason is the complexity of
+  // the clean-up of upstream connections. The clean-up of upstream connection causes RST_STREAM
+  // messages to be sent on corresponding downstream connections. This may actually trigger flood
+  // mitigation on the downstream connections, which causes an exception to be thrown in the middle
+  // of the clean-up loop, leaving resources in a half cleaned up state.
+  // TODO(yanavlasov): add flood mitigation for upstream connections as well.
+  void checkOutboundQueueLimits() override {}
+
   Http::ConnectionCallbacks& callbacks_;
 };
 
@@ -344,8 +400,22 @@ private:
   ConnectionCallbacks& callbacks() override { return callbacks_; }
   int onBeginHeaders(const nghttp2_frame* frame) override;
   int onHeader(const nghttp2_frame* frame, HeaderString&& name, HeaderString&& value) override;
+  void checkOutboundQueueLimits() override;
+
+  // Http::Connection
+  // The reason for overriding the dispatch method is to do flood mitigation only when
+  // processing data from downstream client. Doing flood mitigation when processing upstream
+  // responses makes clean-up tricky, which needs to be improved (see comments for the
+  // ClientConnectionImpl::checkOutboundQueueLimits method). The dispatch method on the
+  // ServerConnectionImpl objects is called only when processing data from the downstream client in
+  // the ConnectionManagerImpl::onData method.
+  void dispatch(Buffer::Instance& data) override;
 
   ServerConnectionCallbacks& callbacks_;
+
+  // This flag indicates that downstream data is being dispatched and turns on flood mitigation
+  // in the checkMaxOutbound*Framed methods.
+  bool dispatching_downstream_data_{false};
 };
 
 } // namespace Http2
diff --git a/source/common/http/utility.cc b/source/common/http/utility.cc
index 52171de11e..0f7db895df 100644
--- a/source/common/http/utility.cc
+++ b/source/common/http/utility.cc
@@ -250,6 +250,11 @@ Utility::parseHttp2Settings(const envoy::api::v2::core::Http2ProtocolOptions& co
   ret.initial_connection_window_size_ =
       PROTOBUF_GET_WRAPPED_OR_DEFAULT(config, initial_connection_window_size,
                                       Http::Http2Settings::DEFAULT_INITIAL_CONNECTION_WINDOW_SIZE);
+  ret.max_outbound_frames_ = PROTOBUF_GET_WRAPPED_OR_DEFAULT(
+      config, max_outbound_frames, Http::Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES);
+  ret.max_outbound_control_frames_ =
+      PROTOBUF_GET_WRAPPED_OR_DEFAULT(config, max_outbound_control_frames,
+                                      Http::Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES);
   ret.allow_connect_ = config.allow_connect();
   ret.allow_metadata_ = config.allow_metadata();
   return ret;
diff --git a/source/common/network/connection_impl.h b/source/common/network/connection_impl.h
index f695b1acb4..96bb326936 100644
--- a/source/common/network/connection_impl.h
+++ b/source/common/network/connection_impl.h
@@ -146,6 +146,8 @@ protected:
   Buffer::OwnedImpl read_buffer_;
   // This must be a WatermarkBuffer, but as it is created by a factory the ConnectionImpl only has
   // a generic pointer.
+  // It MUST be defined after the filter_manager_ as some filters may have callbacks that
+  // write_buffer_ invokes during its clean up.
   Buffer::InstancePtr write_buffer_;
   uint32_t read_buffer_limit_ = 0;
   std::chrono::milliseconds delayed_close_timeout_{0};
diff --git a/test/common/buffer/buffer_test.cc b/test/common/buffer/buffer_test.cc
index aaa1c34ba0..67ef92e577 100644
--- a/test/common/buffer/buffer_test.cc
+++ b/test/common/buffer/buffer_test.cc
@@ -208,6 +208,22 @@ TEST(UnownedSliceTest, CreateDelete) {
   EXPECT_TRUE(release_callback_called);
 }
 
+TEST(UnownedSliceTest, CreateDeleteOwnedBufferFragment) {
+  constexpr char input[] = "hello world";
+  bool release_callback_called = false;
+  auto fragment = OwnedBufferFragmentImpl::create(
+      {input, sizeof(input) - 1}, [&release_callback_called](const OwnedBufferFragmentImpl*) {
+        release_callback_called = true;
+      });
+  auto slice = std::make_unique<UnownedSlice>(*fragment);
+  EXPECT_EQ(11, slice->dataSize());
+  EXPECT_EQ(0, slice->reservableSize());
+  EXPECT_EQ(0, memcmp(slice->data(), input, slice->dataSize()));
+  EXPECT_FALSE(release_callback_called);
+  slice.reset(nullptr);
+  EXPECT_TRUE(release_callback_called);
+}
+
 TEST(SliceDequeTest, CreateDelete) {
   bool slice1_deleted = false;
   bool slice2_deleted = false;
diff --git a/test/common/buffer/owned_impl_test.cc b/test/common/buffer/owned_impl_test.cc
index d009db570f..282ae1961c 100644
--- a/test/common/buffer/owned_impl_test.cc
+++ b/test/common/buffer/owned_impl_test.cc
@@ -96,6 +96,57 @@ TEST_P(OwnedImplTest, AddBufferFragmentDynamicAllocation) {
   EXPECT_TRUE(release_callback_called_);
 }
 
+TEST_P(OwnedImplTest, AddOwnedBufferFragmentWithCleanup) {
+  char input[] = "hello world";
+  const size_t expected_length = sizeof(input) - 1;
+  auto frag = OwnedBufferFragmentImpl::create(
+      {input, expected_length},
+      [this](const OwnedBufferFragmentImpl*) { release_callback_called_ = true; });
+  Buffer::OwnedImpl buffer;
+  verifyImplementation(buffer);
+  buffer.addBufferFragment(*frag);
+  EXPECT_EQ(expected_length, buffer.length());
+
+  const uint64_t partial_drain_size = 5;
+  buffer.drain(partial_drain_size);
+  EXPECT_EQ(expected_length - partial_drain_size, buffer.length());
+  EXPECT_FALSE(release_callback_called_);
+
+  buffer.drain(expected_length - partial_drain_size);
+  EXPECT_EQ(0, buffer.length());
+  EXPECT_TRUE(release_callback_called_);
+}
+
+// Verify that OwnedBufferFragment work correctly when input buffer is allocated on the heap.
+TEST_P(OwnedImplTest, AddOwnedBufferFragmentDynamicAllocation) {
+  char input_stack[] = "hello world";
+  const size_t expected_length = sizeof(input_stack) - 1;
+  char* input = new char[expected_length];
+  std::copy(input_stack, input_stack + expected_length, input);
+
+  auto* frag = OwnedBufferFragmentImpl::create({input, expected_length},
+                                               [this, input](const OwnedBufferFragmentImpl* frag) {
+                                                 release_callback_called_ = true;
+                                                 delete[] input;
+                                                 delete frag;
+                                               })
+                   .release();
+
+  Buffer::OwnedImpl buffer;
+  verifyImplementation(buffer);
+  buffer.addBufferFragment(*frag);
+  EXPECT_EQ(expected_length, buffer.length());
+
+  const uint64_t partial_drain_size = 5;
+  buffer.drain(partial_drain_size);
+  EXPECT_EQ(expected_length - partial_drain_size, buffer.length());
+  EXPECT_FALSE(release_callback_called_);
+
+  buffer.drain(expected_length - partial_drain_size);
+  EXPECT_EQ(0, buffer.length());
+  EXPECT_TRUE(release_callback_called_);
+}
+
 TEST_P(OwnedImplTest, Add) {
   const std::string string1 = "Hello, ", string2 = "World!";
   Buffer::OwnedImpl buffer;
diff --git a/test/common/http/conn_manager_impl_test.cc b/test/common/http/conn_manager_impl_test.cc
index ce4e8af462..6908e459e2 100644
--- a/test/common/http/conn_manager_impl_test.cc
+++ b/test/common/http/conn_manager_impl_test.cc
@@ -2314,6 +2314,27 @@ TEST_F(HttpConnectionManagerImplTest, DownstreamProtocolError) {
   conn_manager_->onData(fake_input, false);
 }
 
+// Verify that FrameFloodException causes connection to be closed abortively.
+TEST_F(HttpConnectionManagerImplTest, FrameFloodError) {
+  InSequence s;
+  setup(false, "");
+
+  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {
+    conn_manager_->newStream(response_encoder_);
+    throw FrameFloodException("too many outbound frames.");
+  }));
+
+  EXPECT_CALL(response_encoder_.stream_, removeCallbacks(_));
+  EXPECT_CALL(filter_factory_, createFilterChain(_)).Times(0);
+
+  // FrameFloodException should result in reset of the streams followed by abortive close.
+  EXPECT_CALL(filter_callbacks_.connection_, close(Network::ConnectionCloseType::NoFlush));
+
+  // Kick off the incoming data.
+  Buffer::OwnedImpl fake_input("1234");
+  conn_manager_->onData(fake_input, false);
+}
+
 TEST_F(HttpConnectionManagerImplTest, IdleTimeoutNoCodec) {
   // Not used in the test.
   delete codec_;
diff --git a/test/common/http/http2/BUILD b/test/common/http/http2/BUILD
index 0c245388af..3540556021 100644
--- a/test/common/http/http2/BUILD
+++ b/test/common/http/http2/BUILD
@@ -32,6 +32,7 @@ envoy_cc_test(
 envoy_cc_test_library(
     name = "codec_impl_test_util",
     hdrs = ["codec_impl_test_util.h"],
+    external_deps = ["abseil_optional"],
     deps = [
         "//source/common/http/http2:codec_lib",
     ],
@@ -57,6 +58,15 @@ envoy_cc_test(
 )
 
 envoy_cc_test_library(
+    name = "http2_frame",
+    srcs = ["http2_frame.cc"],
+    hdrs = ["http2_frame.h"],
+    deps = [
+        "//source/common/common:macros",
+    ],
+)
+
+envoy_cc_test_library(
     name = "frame_replay_lib",
     srcs = ["frame_replay.cc"],
     hdrs = ["frame_replay.h"],
diff --git a/test/common/http/http2/codec_impl_test.cc b/test/common/http/http2/codec_impl_test.cc
index 28b4732f3b..bf70107670 100644
--- a/test/common/http/http2/codec_impl_test.cc
+++ b/test/common/http/http2/codec_impl_test.cc
@@ -97,6 +97,8 @@ public:
     setting.initial_stream_window_size_ = ::testing::get<2>(tp);
     setting.initial_connection_window_size_ = ::testing::get<3>(tp);
     setting.allow_metadata_ = allow_metadata_;
+    setting.max_outbound_frames_ = max_outbound_frames_;
+    setting.max_outbound_control_frames_ = max_outbound_control_frames_;
   }
 
   // corruptMetadataFramePayload assumes data contains at least 10 bytes of the beginning of a
@@ -141,6 +143,8 @@ public:
   bool corrupt_metadata_frame_ = false;
 
   uint32_t max_request_headers_kb_ = Http::DEFAULT_MAX_REQUEST_HEADERS_KB;
+  uint32_t max_outbound_frames_ = Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES;
+  uint32_t max_outbound_control_frames_ = Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES;
 };
 
 class Http2CodecImplTest : public ::testing::TestWithParam<Http2SettingsTestParam>,
@@ -1039,6 +1043,212 @@ TEST_P(Http2CodecImplTestAll, TestCodecHeaderCompression) {
   }
 }
 
+// Verify that codec detects PING flood
+TEST_P(Http2CodecImplTest, PingFlood) {
+  initialize();
+
+  TestHeaderMapImpl request_headers;
+  HttpTestUtility::addDefaultHeaders(request_headers);
+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
+  request_encoder_->encodeHeaders(request_headers, false);
+
+  // Send one frame above the outbound control queue size limit
+  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES + 1; ++i) {
+    EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
+  }
+
+  int ack_count = 0;
+  Buffer::OwnedImpl buffer;
+  ON_CALL(server_connection_, write(_, _))
+      .WillByDefault(Invoke([&buffer, &ack_count](Buffer::Instance& frame, bool) {
+        ++ack_count;
+        buffer.move(frame);
+      }));
+
+  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);
+  EXPECT_EQ(ack_count, Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES);
+  EXPECT_EQ(1, stats_store_.counter("http2.outbound_control_flood").value());
+}
+
+// Verify that outbound control frame counter decreases when send buffer is drained
+TEST_P(Http2CodecImplTest, PingFloodCounterReset) {
+  static const int kMaxOutboundControlFrames = 100;
+  max_outbound_control_frames_ = kMaxOutboundControlFrames;
+  initialize();
+
+  TestHeaderMapImpl request_headers;
+  HttpTestUtility::addDefaultHeaders(request_headers);
+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
+  request_encoder_->encodeHeaders(request_headers, false);
+
+  for (int i = 0; i < kMaxOutboundControlFrames; ++i) {
+    EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
+  }
+
+  int ack_count = 0;
+  Buffer::OwnedImpl buffer;
+  ON_CALL(server_connection_, write(_, _))
+      .WillByDefault(Invoke([&buffer, &ack_count](Buffer::Instance& frame, bool) {
+        ++ack_count;
+        buffer.move(frame);
+      }));
+
+  // We should be 1 frame under the control frame flood mitigation threshold.
+  EXPECT_NO_THROW(client_->sendPendingFrames());
+  EXPECT_EQ(ack_count, kMaxOutboundControlFrames);
+
+  // Drain kMaxOutboundFrames / 2 slices from the send buffer
+  buffer.drain(buffer.length() / 2);
+
+  // Send kMaxOutboundFrames / 2 more pings.
+  for (int i = 0; i < kMaxOutboundControlFrames / 2; ++i) {
+    EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
+  }
+  // The number of outbound frames should be half of max so the connection should not be terminated.
+  EXPECT_NO_THROW(client_->sendPendingFrames());
+
+  // 1 more ping frame should overflow the outbound frame limit.
+  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
+  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);
+}
+
+// Verify that codec detects flood of outbound HEADER frames
+TEST_P(Http2CodecImplTest, ResponseHeadersFlood) {
+  initialize();
+
+  TestHeaderMapImpl request_headers;
+  HttpTestUtility::addDefaultHeaders(request_headers);
+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
+  request_encoder_->encodeHeaders(request_headers, false);
+
+  int frame_count = 0;
+  Buffer::OwnedImpl buffer;
+  ON_CALL(server_connection_, write(_, _))
+      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
+        ++frame_count;
+        buffer.move(frame);
+      }));
+
+  TestHeaderMapImpl response_headers{{":status", "200"}};
+  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES + 1; ++i) {
+    EXPECT_NO_THROW(response_encoder_->encodeHeaders(response_headers, false));
+  }
+  // Presently flood mitigation is done only when processing downstream data
+  // So we need to send stream from downstream client to trigger mitigation
+  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
+  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);
+
+  EXPECT_EQ(frame_count, Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
+  EXPECT_EQ(1, stats_store_.counter("http2.outbound_flood").value());
+}
+
+// Verify that codec detects flood of outbound DATA frames
+TEST_P(Http2CodecImplTest, ResponseDataFlood) {
+  initialize();
+
+  TestHeaderMapImpl request_headers;
+  HttpTestUtility::addDefaultHeaders(request_headers);
+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
+  request_encoder_->encodeHeaders(request_headers, false);
+
+  int frame_count = 0;
+  Buffer::OwnedImpl buffer;
+  ON_CALL(server_connection_, write(_, _))
+      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
+        ++frame_count;
+        buffer.move(frame);
+      }));
+
+  TestHeaderMapImpl response_headers{{":status", "200"}};
+  response_encoder_->encodeHeaders(response_headers, false);
+  // Account for the single HEADERS frame above
+  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
+    Buffer::OwnedImpl data("0");
+    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
+  }
+  // Presently flood mitigation is done only when processing downstream data
+  // So we need to send stream from downstream client to trigger mitigation
+  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
+  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);
+
+  EXPECT_EQ(frame_count, Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
+  EXPECT_EQ(1, stats_store_.counter("http2.outbound_flood").value());
+}
+
+// Verify that outbound frame counter decreases when send buffer is drained
+TEST_P(Http2CodecImplTest, ResponseDataFloodCounterReset) {
+  static const int kMaxOutboundFrames = 100;
+  max_outbound_frames_ = kMaxOutboundFrames;
+  initialize();
+
+  TestHeaderMapImpl request_headers;
+  HttpTestUtility::addDefaultHeaders(request_headers);
+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
+  request_encoder_->encodeHeaders(request_headers, false);
+
+  int frame_count = 0;
+  Buffer::OwnedImpl buffer;
+  ON_CALL(server_connection_, write(_, _))
+      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
+        ++frame_count;
+        buffer.move(frame);
+      }));
+
+  TestHeaderMapImpl response_headers{{":status", "200"}};
+  response_encoder_->encodeHeaders(response_headers, false);
+  // Account for the single HEADERS frame above
+  for (uint32_t i = 0; i < kMaxOutboundFrames - 1; ++i) {
+    Buffer::OwnedImpl data("0");
+    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
+  }
+
+  EXPECT_EQ(frame_count, kMaxOutboundFrames);
+  // Drain kMaxOutboundFrames / 2 slices from the send buffer
+  buffer.drain(buffer.length() / 2);
+
+  for (uint32_t i = 0; i < kMaxOutboundFrames / 2 + 1; ++i) {
+    Buffer::OwnedImpl data("0");
+    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
+  }
+
+  // Presently flood mitigation is done only when processing downstream data
+  // So we need to send a frame from downstream client to trigger mitigation
+  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
+  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);
+}
+
+// Verify that control frames are added to the counter of outbound frames of all types.
+TEST_P(Http2CodecImplTest, PingStacksWithDataFlood) {
+  initialize();
+
+  TestHeaderMapImpl request_headers;
+  HttpTestUtility::addDefaultHeaders(request_headers);
+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
+  request_encoder_->encodeHeaders(request_headers, false);
+
+  int frame_count = 0;
+  Buffer::OwnedImpl buffer;
+  ON_CALL(server_connection_, write(_, _))
+      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
+        ++frame_count;
+        buffer.move(frame);
+      }));
+
+  TestHeaderMapImpl response_headers{{":status", "200"}};
+  response_encoder_->encodeHeaders(response_headers, false);
+  // Account for the single HEADERS frame above
+  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES - 1; ++i) {
+    Buffer::OwnedImpl data("0");
+    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
+  }
+  // Send one PING frame above the outbound queue size limit
+  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
+  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);
+
+  EXPECT_EQ(frame_count, Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES);
+  EXPECT_EQ(1, stats_store_.counter("http2.outbound_flood").value());
+}
+
 } // namespace Http2
 } // namespace Http
 } // namespace Envoy
diff --git a/test/common/http/http2/codec_impl_test_util.h b/test/common/http/http2/codec_impl_test_util.h
index b642701265..2c4652ee0f 100644
--- a/test/common/http/http2/codec_impl_test_util.h
+++ b/test/common/http/http2/codec_impl_test_util.h
@@ -26,6 +26,7 @@ public:
   }
   nghttp2_session* session() { return session_; }
   using ClientConnectionImpl::getStream;
+  using ConnectionImpl::sendPendingFrames;
 };
 
 } // namespace Http2
diff --git a/test/common/http/http2/http2_frame.cc b/test/common/http/http2/http2_frame.cc
new file mode 100644
index 0000000000..ca4fb858a0
--- /dev/null
+++ b/test/common/http/http2/http2_frame.cc
@@ -0,0 +1,148 @@
+#include "test/common/http/http2/http2_frame.h"
+
+#include <arpa/inet.h>
+
+#include <type_traits>
+
+namespace {
+
+// Make request stream ID in the network byte order
+uint32_t makeRequestStreamId(uint32_t stream_id) { return htonl((stream_id << 1) | 1); }
+
+// All this templatized stuff is for the typesafe constexpr bitwise ORing of the "enum class" values
+template <typename First, typename... Rest> struct FirstArgType { using type = First; };
+
+template <typename Flag> constexpr uint8_t orFlags(Flag flag) { return static_cast<uint8_t>(flag); }
+
+template <typename Flag, typename... Flags> constexpr uint8_t orFlags(Flag first, Flags... rest) {
+  static_assert(std::is_same<Flag, typename FirstArgType<Flags...>::type>::value,
+                "All flag types must be the same!");
+  return static_cast<uint8_t>(first) | orFlags(rest...);
+}
+
+} // namespace
+
+namespace Envoy {
+namespace Http {
+namespace Http2 {
+
+const char Http2Frame::Preamble[25] = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n";
+
+void Http2Frame::setHeader(absl::string_view header) {
+  ASSERT(header.size() >= HeaderSize);
+  data_.assign(HeaderSize, 0);
+  memcpy(&data_[0], header.data(), HeaderSize);
+  data_.resize(HeaderSize + payloadSize());
+}
+
+void Http2Frame::setPayload(absl::string_view payload) {
+  ASSERT(payload.size() >= payloadSize());
+  memcpy(&data_[HeaderSize], payload.data(), payloadSize());
+}
+
+uint32_t Http2Frame::payloadSize() const {
+  return (uint32_t(data_[0]) << 16) + (uint32_t(data_[1]) << 8) + uint32_t(data_[2]);
+}
+
+Http2Frame::ResponseStatus Http2Frame::responseStatus() const {
+  if (empty() || Type::HEADERS != type() || size() <= HeaderSize ||
+      ((data_[HeaderSize] & 0x80) == 0)) {
+    return ResponseStatus::UNKNOWN;
+  }
+  // See https://tools.ietf.org/html/rfc7541#appendix-A for header values
+  switch (static_cast<StaticHeaderIndex>(data_[HeaderSize] & 0x7f)) {
+  case StaticHeaderIndex::STATUS_200:
+    return ResponseStatus::_200;
+  case StaticHeaderIndex::STATUS_404:
+    return ResponseStatus::_404;
+  default:
+    break;
+  }
+  return ResponseStatus::UNKNOWN;
+}
+
+void Http2Frame::buildHeader(Type type, uint32_t payload_size, uint8_t flags, uint32_t stream_id) {
+  data_.assign(payload_size + HeaderSize, 0);
+  setPayloadSize(payload_size);
+  data_[3] = static_cast<uint8_t>(type);
+  data_[4] = flags;
+  if (stream_id) {
+    memcpy(&data_[5], &stream_id, sizeof(stream_id));
+  }
+}
+
+void Http2Frame::setPayloadSize(uint32_t size) {
+  data_[0] = (size >> 16) & 0xff;
+  data_[1] = (size >> 8) & 0xff;
+  data_[2] = size & 0xff;
+}
+
+void Http2Frame::appendHpackInt(uint64_t value, unsigned char prefix_mask) {
+  if (value < prefix_mask) {
+    data_.push_back(value);
+  } else {
+    data_.push_back(prefix_mask);
+    value -= prefix_mask;
+
+    while (value >= 128) {
+      data_.push_back((value & 0x7f) | 0x80);
+      value >>= 7;
+    }
+    data_.push_back(value);
+  }
+}
+
+// See https://tools.ietf.org/html/rfc7541#section-6.1 for header representations
+
+void Http2Frame::appendStaticHeader(StaticHeaderIndex index) {
+  data_.push_back(0x80 | static_cast<uint8_t>(index));
+}
+
+void Http2Frame::appendHeaderWithoutIndexing(StaticHeaderIndex index, absl::string_view value) {
+  appendHpackInt(static_cast<uint8_t>(index), 0xf);
+  appendHpackInt(value.size(), 0x7f);
+  appendData(value);
+}
+
+Http2Frame Http2Frame::makePingFrame(absl::string_view data) {
+  static constexpr size_t kPingPayloadSize = 8;
+  Http2Frame frame;
+  frame.buildHeader(Type::PING, kPingPayloadSize);
+  if (!data.empty()) {
+    memcpy(&frame.data_[HeaderSize], data.data(), std::min(kPingPayloadSize, data.size()));
+  }
+  return frame;
+}
+
+Http2Frame Http2Frame::makeEmptySettingsFrame(SettingsFlags flags) {
+  Http2Frame frame;
+  frame.buildHeader(Type::SETTINGS, 0, static_cast<uint8_t>(flags));
+  return frame;
+}
+
+Http2Frame Http2Frame::makeMalformedRequest(uint32_t stream_index) {
+  Http2Frame frame;
+  frame.buildHeader(Type::HEADERS, 0, orFlags(HeadersFlags::END_STREAM, HeadersFlags::END_HEADERS),
+                    makeRequestStreamId(stream_index));
+  frame.appendStaticHeader(
+      StaticHeaderIndex::STATUS_200); // send :status as request header, which is invalid
+  frame.adjustPayloadSize();
+  return frame;
+}
+
+Http2Frame Http2Frame::makeRequest(uint32_t stream_index, absl::string_view host,
+                                   absl::string_view path) {
+  Http2Frame frame;
+  frame.buildHeader(Type::HEADERS, 0, orFlags(HeadersFlags::END_STREAM, HeadersFlags::END_HEADERS),
+                    makeRequestStreamId(stream_index));
+  frame.appendStaticHeader(StaticHeaderIndex::METHOD_GET);
+  frame.appendStaticHeader(StaticHeaderIndex::SCHEME_HTTPS);
+  frame.appendHeaderWithoutIndexing(StaticHeaderIndex::PATH, path);
+  frame.appendHeaderWithoutIndexing(StaticHeaderIndex::HOST, host);
+  frame.adjustPayloadSize();
+  return frame;
+}
+
+} // namespace Http2
+} // namespace Http
+} // namespace Envoy
diff --git a/test/common/http/http2/http2_frame.h b/test/common/http/http2/http2_frame.h
new file mode 100644
index 0000000000..88a051a2f1
--- /dev/null
+++ b/test/common/http/http2/http2_frame.h
@@ -0,0 +1,126 @@
+#pragma once
+
+#include <cstdint>
+#include <string>
+#include <vector>
+
+#include "common/common/assert.h"
+
+#include "absl/strings/string_view.h"
+
+namespace Envoy {
+namespace Http {
+namespace Http2 {
+
+// Rudimentary facility for building and parsing of HTTP2 frames for unit tests
+class Http2Frame {
+  using DataContainer = std::vector<uint8_t>;
+
+public:
+  Http2Frame() = default;
+
+  using iterator = DataContainer::iterator;
+  using const_iterator = DataContainer::const_iterator;
+
+  static constexpr size_t HeaderSize = 9;
+  static const char Preamble[25];
+
+  enum class Type : uint8_t {
+    DATA = 0,
+    HEADERS,
+    PRIORITY,
+    RST_STREAM,
+    SETTINGS,
+    PUSH_PROMISE,
+    PING,
+    GOAWAY,
+    WINDOW_UPDATE,
+    CONTINUATION
+  };
+
+  enum class SettingsFlags : uint8_t {
+    NONE = 0,
+    ACK = 1,
+  };
+
+  enum class HeadersFlags : uint8_t {
+    NONE = 0,
+    END_STREAM = 1,
+    END_HEADERS = 4,
+  };
+
+  // See https://tools.ietf.org/html/rfc7541#appendix-A for static header indexes
+  enum class StaticHeaderIndex : uint8_t {
+    UNKNOWN,
+    METHOD_GET = 2,
+    PATH = 4,
+    STATUS_200 = 8,
+    STATUS_404 = 13,
+    SCHEME_HTTPS = 7,
+    HOST = 38,
+  };
+
+  enum class ResponseStatus { UNKNOWN, _200, _404 };
+
+  // Methods for creating HTTP2 frames
+  static Http2Frame makePingFrame(absl::string_view data = nullptr);
+  static Http2Frame makeEmptySettingsFrame(SettingsFlags flags = SettingsFlags::NONE);
+  static Http2Frame makeMalformedRequest(uint32_t stream_index);
+  static Http2Frame makeRequest(uint32_t stream_index, absl::string_view host,
+                                absl::string_view path);
+
+  Type type() const { return static_cast<Type>(data_[3]); }
+  ResponseStatus responseStatus() const;
+
+  // Copy HTTP2 header. The `header` parameter must at least be HeaderSize long.
+  // Allocates payload size based on the value in the header.
+  void setHeader(absl::string_view header);
+
+  // Copy payloadSize() bytes from the `payload`. The `payload` must be at least payloadSize() long.
+  void setPayload(absl::string_view payload);
+
+  // Convert to `std::string` for convenience.
+  explicit operator std::string() const {
+    if (data_.empty()) {
+      return {};
+    }
+    return std::string(reinterpret_cast<const char*>(data()), size());
+  }
+
+  uint32_t payloadSize() const;
+  // Total size of the frame
+  size_t size() const { return data_.size(); }
+  // Access to the raw frame bytes
+  const uint8_t* data() const { return data_.data(); }
+  iterator begin() { return data_.begin(); }
+  iterator end() { return data_.end(); }
+  const_iterator begin() const { return data_.begin(); }
+  const_iterator end() const { return data_.end(); }
+  bool empty() const { return data_.empty(); }
+
+private:
+  void buildHeader(Type type, uint32_t payload_size = 0, uint8_t flags = 0, uint32_t stream_id = 0);
+  void setPayloadSize(uint32_t size);
+
+  // This method appends HPACK encoded uint64_t to the payload. adjustPayloadSize() must be called
+  // after calling this method (possibly multiple times) to write new payload length to the HTTP2
+  // header.
+  void appendHpackInt(uint64_t value, unsigned char prefix_mask);
+  void appendData(absl::string_view data) { data_.insert(data_.end(), data.begin(), data.end()); }
+
+  // Headers are directly encoded
+  void appendStaticHeader(StaticHeaderIndex index);
+  void appendHeaderWithoutIndexing(StaticHeaderIndex index, absl::string_view value);
+
+  // This method updates payload length in the HTTP2 header based on the size of the data_
+  void adjustPayloadSize() {
+    ASSERT(size() >= HeaderSize);
+    setPayloadSize(size() - HeaderSize);
+  }
+
+  DataContainer data_;
+};
+
+} // namespace Http2
+} // namespace Http
+} // namespace Envoy
diff --git a/test/common/http/utility_test.cc b/test/common/http/utility_test.cc
index daab4c044d..4c27ead4a8 100644
--- a/test/common/http/utility_test.cc
+++ b/test/common/http/utility_test.cc
@@ -265,6 +265,9 @@ TEST(HttpUtility, parseHttp2Settings) {
               http2_settings.initial_stream_window_size_);
     EXPECT_EQ(Http2Settings::DEFAULT_INITIAL_CONNECTION_WINDOW_SIZE,
               http2_settings.initial_connection_window_size_);
+    EXPECT_EQ(Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES, http2_settings.max_outbound_frames_);
+    EXPECT_EQ(Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES,
+              http2_settings.max_outbound_control_frames_);
   }
 
   {
diff --git a/test/config/utility.cc b/test/config/utility.cc
index 8a90d921b1..94fcc4bc72 100644
--- a/test/config/utility.cc
+++ b/test/config/utility.cc
@@ -650,6 +650,21 @@ void ConfigHelper::setLds(absl::string_view version_info) {
   TestUtility::renameFile(file, lds_filename);
 }
 
+void ConfigHelper::setOutboundFramesLimits(uint32_t max_all_frames, uint32_t max_control_frames) {
+  auto filter = getFilterFromListener("envoy.http_connection_manager");
+  if (filter) {
+    envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager hcm_config;
+    loadHttpConnectionManager(hcm_config);
+    if (hcm_config.codec_type() ==
+        envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager::HTTP2) {
+      auto* options = hcm_config.mutable_http2_protocol_options();
+      options->mutable_max_outbound_frames()->set_value(max_all_frames);
+      options->mutable_max_outbound_control_frames()->set_value(max_control_frames);
+      storeHttpConnectionManager(hcm_config);
+    }
+  }
+}
+
 CdsHelper::CdsHelper() : cds_path_(TestEnvironment::writeStringToFileForTest("cds.pb_text", "")) {}
 
 void CdsHelper::setCds(const std::vector<envoy::api::v2::Cluster>& clusters) {
diff --git a/test/config/utility.h b/test/config/utility.h
index 5be493a51b..0abf01c3bf 100644
--- a/test/config/utility.h
+++ b/test/config/utility.h
@@ -149,6 +149,9 @@ public:
   // and write it to the lds file.
   void setLds(absl::string_view version_info);
 
+  // Set limits on pending outbound frames.
+  void setOutboundFramesLimits(uint32_t max_all_frames, uint32_t max_control_frames);
+
   // Return the bootstrap configuration for hand-off to Envoy.
   const envoy::config::bootstrap::v2::Bootstrap& bootstrap() { return bootstrap_; }
 
diff --git a/test/integration/BUILD b/test/integration/BUILD
index fff182f022..56e0101f5d 100644
--- a/test/integration/BUILD
+++ b/test/integration/BUILD
@@ -207,6 +207,7 @@ envoy_cc_test(
         "//source/extensions/filters/http/buffer:config",
         "//source/extensions/filters/http/dynamo:config",
         "//source/extensions/filters/http/health_check:config",
+        "//test/common/http/http2:http2_frame",
         "//test/integration/filters:stop_iteration_and_continue",
         "//test/mocks/http:http_mocks",
         "//test/mocks/upstream:upstream_mocks",
diff --git a/test/integration/http2_integration_test.cc b/test/integration/http2_integration_test.cc
index cddc0a6253..ea7e686adf 100644
--- a/test/integration/http2_integration_test.cc
+++ b/test/integration/http2_integration_test.cc
@@ -1,5 +1,6 @@
 #include "test/integration/http2_integration_test.h"
 
+#include <algorithm>
 #include <string>
 
 #include "common/buffer/buffer_impl.h"
@@ -1071,4 +1072,161 @@ TEST_P(Http2RingHashIntegrationTest, CookieRoutingWithCookieWithTtlSet) {
   EXPECT_EQ(served_by.size(), 1);
 }
 
+namespace {
+const int64_t TransmitThreshold = 100 * 1024 * 1024;
+} // namespace
+
+void Http2FloodMitigationTest::beginSession() {
+  setDownstreamProtocol(Http::CodecClient::Type::HTTP2);
+  setUpstreamProtocol(FakeHttpConnection::Type::HTTP2);
+  // set lower outbound frame limits to make tests run faster
+  config_helper_.setOutboundFramesLimits(1000, 100);
+  initialize();
+  tcp_client_ = makeTcpConnection(lookupPort("http"));
+  startHttp2Session();
+}
+
+Http2Frame Http2FloodMitigationTest::readFrame() {
+  Http2Frame frame;
+  tcp_client_->waitForData(frame.HeaderSize);
+  frame.setHeader(tcp_client_->data());
+  tcp_client_->clearData(frame.HeaderSize);
+  auto len = frame.payloadSize();
+  if (len) {
+    tcp_client_->waitForData(len);
+    frame.setPayload(tcp_client_->data());
+    tcp_client_->clearData(len);
+  }
+  return frame;
+}
+
+void Http2FloodMitigationTest::sendFame(const Http2Frame& frame) {
+  ASSERT_TRUE(tcp_client_->connected());
+  tcp_client_->write(std::string(frame), false, false);
+}
+
+void Http2FloodMitigationTest::startHttp2Session() {
+  tcp_client_->write(Http2Frame::Preamble, false, false);
+
+  // Send empty initial SETTINGS frame.
+  auto settings = Http2Frame::makeEmptySettingsFrame();
+  tcp_client_->write(std::string(settings), false, false);
+
+  // Read initial SETTINGS frame from the server.
+  readFrame();
+
+  // Send an SETTINGS ACK.
+  settings = Http2Frame::makeEmptySettingsFrame(Http2Frame::SettingsFlags::ACK);
+  tcp_client_->write(std::string(settings), false, false);
+
+  // read pending SETTINGS and WINDOW_UPDATE frames
+  readFrame();
+  readFrame();
+}
+
+// Verify that the server detects the flood of the given frame.
+void Http2FloodMitigationTest::floodServer(const Http2Frame& frame) {
+  config_helper_.setBufferLimits(1024, 1024); // Set buffer limits upstream and downstream.
+  beginSession();
+
+  // pack the as many frames as we can into 16k buffer
+  const int FrameCount = (16 * 1024) / frame.size();
+  std::vector<char> buf(FrameCount * frame.size());
+  for (auto pos = buf.begin(); pos != buf.end();) {
+    pos = std::copy(frame.begin(), frame.end(), pos);
+  }
+
+  tcp_client_->readDisable(true);
+  int64_t total_bytes_sent = 0;
+  // If the flood protection is not working this loop will keep going
+  // forever until it is killed by blaze timer or run out of memory.
+  // Add early stop if we have sent more than 100M of frames, as it this
+  // point it is obvious something is wrong.
+  while (total_bytes_sent < TransmitThreshold && tcp_client_->connected()) {
+    tcp_client_->write({buf.begin(), buf.end()}, false, false);
+    total_bytes_sent += buf.size();
+  }
+
+  EXPECT_LE(total_bytes_sent, TransmitThreshold) << "Flood mitigation is broken.";
+  EXPECT_EQ(1, test_server_->counter("http2.outbound_control_flood")->value());
+  // Verify that connection was closed abortively
+  EXPECT_EQ(0,
+            test_server_->counter("http.config_test.downstream_cx_delayed_close_timeout")->value());
+}
+
+// Verify that the server detects the flood using specified request parameters.
+void Http2FloodMitigationTest::floodServer(absl::string_view host, absl::string_view path,
+                                           Http2Frame::ResponseStatus expected_http_status) {
+  uint32_t request_idx = 0;
+  auto request = Http2Frame::makeRequest(request_idx, host, path);
+  sendFame(request);
+  auto frame = readFrame();
+  EXPECT_EQ(Http2Frame::Type::HEADERS, frame.type());
+  EXPECT_EQ(expected_http_status, frame.responseStatus());
+  tcp_client_->readDisable(true);
+  uint64_t total_bytes_sent = 0;
+  while (total_bytes_sent < TransmitThreshold && tcp_client_->connected()) {
+    request = Http2Frame::makeRequest(++request_idx, host, path);
+    sendFame(request);
+    total_bytes_sent += request.size();
+  }
+  EXPECT_LE(total_bytes_sent, TransmitThreshold) << "Flood mitigation is broken.";
+  EXPECT_EQ(1, test_server_->counter("http2.outbound_flood")->value());
+  // Verify that connection was closed abortively
+  EXPECT_EQ(0,
+            test_server_->counter("http.config_test.downstream_cx_delayed_close_timeout")->value());
+}
+
+INSTANTIATE_TEST_SUITE_P(IpVersions, Http2FloodMitigationTest,
+                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
+                         TestUtility::ipTestParamsToString);
+
+TEST_P(Http2FloodMitigationTest, Ping) { floodServer(Http2Frame::makePingFrame()); }
+
+TEST_P(Http2FloodMitigationTest, Settings) { floodServer(Http2Frame::makeEmptySettingsFrame()); }
+
+// Verify that the server can detect flood of internally generated 404 responses.
+TEST_P(Http2FloodMitigationTest, 404) {
+  // Change the default route to be restrictive, and send a request to a non existent route.
+  config_helper_.setDefaultHostAndRoute("foo.com", "/found");
+  beginSession();
+
+  // Send requests to a non existent path to generate 404s
+  floodServer("host", "/notfound", Http2Frame::ResponseStatus::_404);
+}
+
+// Verify that the server can detect flood of DATA frames
+TEST_P(Http2FloodMitigationTest, Data) {
+  // Set large buffer limits so the test is not affected by the flow control.
+  config_helper_.setBufferLimits(1024 * 1024 * 1024, 1024 * 1024 * 1024);
+  autonomous_upstream_ = true;
+  beginSession();
+  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);
+
+  floodServer("host", "/test/long/url", Http2Frame::ResponseStatus::_200);
+}
+
+// Verify that the server can detect flood of RST_STREAM frames.
+TEST_P(Http2FloodMitigationTest, RST_STREAM) {
+  beginSession();
+
+  int i = 0;
+  auto request = Http::Http2::Http2Frame::makeMalformedRequest(i);
+  sendFame(request);
+  auto response = readFrame();
+  // Make sure we've got RST_STREAM from the server
+  EXPECT_EQ(Http2Frame::Type::RST_STREAM, response.type());
+  uint64_t total_bytes_sent = 0;
+  while (total_bytes_sent < TransmitThreshold && tcp_client_->connected()) {
+    request = Http::Http2::Http2Frame::makeMalformedRequest(++i);
+    sendFame(request);
+    total_bytes_sent += request.size();
+  }
+  EXPECT_LE(total_bytes_sent, TransmitThreshold) << "Flood mitigation is broken.";
+  EXPECT_EQ(1, test_server_->counter("http2.outbound_control_flood")->value());
+  // Verify that connection was closed abortively
+  EXPECT_EQ(0,
+            test_server_->counter("http.config_test.downstream_cx_delayed_close_timeout")->value());
+}
+
 } // namespace Envoy
diff --git a/test/integration/http2_integration_test.h b/test/integration/http2_integration_test.h
index c910d6e78c..b993b0b47e 100644
--- a/test/integration/http2_integration_test.h
+++ b/test/integration/http2_integration_test.h
@@ -1,9 +1,12 @@
 #pragma once
 
+#include "test/common/http/http2/http2_frame.h"
 #include "test/integration/http_integration.h"
 
 #include "gtest/gtest.h"
 
+using Envoy::Http::Http2::Http2Frame;
+
 namespace Envoy {
 class Http2IntegrationTest : public testing::TestWithParam<Network::Address::IpVersion>,
                              public HttpIntegrationTest {
@@ -46,4 +49,21 @@ public:
     setUpstreamProtocol(FakeHttpConnection::Type::HTTP2);
   }
 };
+
+class Http2FloodMitigationTest : public testing::TestWithParam<Network::Address::IpVersion>,
+                                 public HttpIntegrationTest {
+public:
+  Http2FloodMitigationTest() : HttpIntegrationTest(Http::CodecClient::Type::HTTP2, GetParam()) {}
+
+protected:
+  void startHttp2Session();
+  void floodServer(const Http2Frame& frame);
+  void floodServer(absl::string_view host, absl::string_view path,
+                   Http2Frame::ResponseStatus expected_http_status);
+  Http2Frame readFrame();
+  void sendFame(const Http2Frame& frame);
+  void beginSession();
+
+  IntegrationTcpClientPtr tcp_client_;
+};
 } // namespace Envoy
diff --git a/test/integration/integration.cc b/test/integration/integration.cc
index a34d52b6a9..8131d51329 100644
--- a/test/integration/integration.cc
+++ b/test/integration/integration.cc
@@ -180,6 +180,15 @@ void IntegrationTcpClient::waitForData(const std::string& data, bool exact_match
   connection_->dispatcher().run(Event::Dispatcher::RunType::Block);
 }
 
+void IntegrationTcpClient::waitForData(size_t length) {
+  if (payload_reader_->data().size() >= length) {
+    return;
+  }
+
+  payload_reader_->setLengthToWaitFor(length);
+  connection_->dispatcher().run(Event::Dispatcher::RunType::Block);
+}
+
 void IntegrationTcpClient::waitForDisconnect(bool ignore_spurious_events) {
   if (ignore_spurious_events) {
     while (!disconnected_) {
diff --git a/test/integration/integration.h b/test/integration/integration.h
index 873dde090a..b263d78cdd 100644
--- a/test/integration/integration.h
+++ b/test/integration/integration.h
@@ -95,13 +95,16 @@ public:
 
   void close();
   void waitForData(const std::string& data, bool exact_match = true);
+  // wait for at least `length` bytes to be received
+  void waitForData(size_t length);
   void waitForDisconnect(bool ignore_spurious_events = false);
   void waitForHalfClose();
   void readDisable(bool disabled);
   void write(const std::string& data, bool end_stream = false, bool verify = true);
   const std::string& data() { return payload_reader_->data(); }
   bool connected() const { return !disconnected_; }
-  void clearData() { payload_reader_->clearData(); }
+  // clear up to the `count` number of bytes of received data
+  void clearData(size_t count = std::string::npos) { payload_reader_->clearData(count); }
 
 private:
   struct ConnectionCallbacks : public Network::ConnectionCallbacks {
diff --git a/test/integration/tcp_proxy_integration_test.cc b/test/integration/tcp_proxy_integration_test.cc
index c79d49e9fb..060c24afdb 100644
--- a/test/integration/tcp_proxy_integration_test.cc
+++ b/test/integration/tcp_proxy_integration_test.cc
@@ -43,6 +43,15 @@ TEST_P(TcpProxyIntegrationTest, TcpProxyUpstreamWritesFirst) {
   // Make sure inexact matches work also on data already received.
   tcp_client->waitForData("ello", false);
 
+  // Make sure length based wait works for the data already received
+  tcp_client->waitForData(5);
+  tcp_client->waitForData(4);
+
+  // Drain part of the received message
+  tcp_client->clearData(2);
+  tcp_client->waitForData("llo");
+  tcp_client->waitForData(3);
+
   tcp_client->write("hello");
   ASSERT_TRUE(fake_upstream_connection->waitForData(5));
 
diff --git a/test/integration/utility.cc b/test/integration/utility.cc
index ecf5fd26ae..b19e4df179 100644
--- a/test/integration/utility.cc
+++ b/test/integration/utility.cc
@@ -148,6 +148,11 @@ Network::FilterStatus WaitForPayloadReader::onData(Buffer::Instance& data, bool
     dispatcher_.exit();
   }
 
+  if (wait_for_length_ && data_.size() >= length_to_wait_for_) {
+    wait_for_length_ = false;
+    dispatcher_.exit();
+  }
+
   return Network::FilterStatus::StopIteration;
 }
 
diff --git a/test/integration/utility.h b/test/integration/utility.h
index 7d3dc1b2fc..6554234ddc 100644
--- a/test/integration/utility.h
+++ b/test/integration/utility.h
@@ -181,9 +181,14 @@ public:
     data_to_wait_for_ = data;
     exact_match_ = exact_match;
   }
+  void setLengthToWaitFor(size_t length) {
+    ASSERT(!wait_for_length_);
+    length_to_wait_for_ = length;
+    wait_for_length_ = true;
+  }
   const std::string& data() { return data_; }
   bool readLastByte() { return read_end_stream_; }
-  void clearData() { data_.clear(); }
+  void clearData(size_t count = std::string::npos) { data_.erase(0, count); }
 
 private:
   Event::Dispatcher& dispatcher_;
@@ -191,6 +196,8 @@ private:
   std::string data_;
   bool exact_match_{true};
   bool read_end_stream_{};
+  size_t length_to_wait_for_{0};
+  bool wait_for_length_{false};
 };
 
 } // namespace Envoy
diff --git a/test/test_common/utility.cc b/test/test_common/utility.cc
index 02b950cb10..38ec2670f9 100644
--- a/test/test_common/utility.cc
+++ b/test/test_common/utility.cc
@@ -385,6 +385,8 @@ const uint32_t Http2Settings::DEFAULT_MAX_CONCURRENT_STREAMS;
 const uint32_t Http2Settings::DEFAULT_INITIAL_STREAM_WINDOW_SIZE;
 const uint32_t Http2Settings::DEFAULT_INITIAL_CONNECTION_WINDOW_SIZE;
 const uint32_t Http2Settings::MIN_INITIAL_STREAM_WINDOW_SIZE;
+const uint32_t Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES;
+const uint32_t Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES;
 
 TestHeaderMapImpl::TestHeaderMapImpl() = default;
 
-- 
2.11.0

