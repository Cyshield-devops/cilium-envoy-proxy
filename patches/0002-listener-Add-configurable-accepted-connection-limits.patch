From ad6414464bcf5dc0a8ebf170ae5840e4b91385b0 Mon Sep 17 00:00:00 2001
From: Lizan Zhou <lizan@tetrate.io>
Date: Fri, 12 Jun 2020 19:41:02 -0700
Subject: [PATCH 2/7] listener: Add configurable accepted connection limits
 (#153)

Add support for per-listener limits on accepted connections.

Signed-off-by: Tony Allen <tony@allen.gg>
Signed-off-by: Lizan Zhou <lizan@tetrate.io>
---
 .../configuration/best_practices/edge.rst     |  12 ++
 .../configuration/listeners/listeners.rst     |   1 +
 docs/root/configuration/listeners/runtime.rst |   8 ++
 docs/root/configuration/listeners/stats.rst   |   1 +
 .../faq/configuration/resource_limits.rst     |  16 +++
 docs/root/faq/overview.rst                    |   1 +
 docs/root/intro/version_history.rst           |   1 +
 examples/front-proxy/front-envoy.yaml         |  10 ++
 include/envoy/network/listener.h              |   6 +
 .../common/upstream/resource_manager_impl.h   |   5 +-
 source/server/connection_handler_impl.cc      |   8 ++
 source/server/connection_handler_impl.h       |  12 +-
 source/server/http/BUILD                      |   1 +
 source/server/http/admin.h                    |   3 +
 source/server/listener_impl.cc                |  15 ++-
 source/server/listener_impl.h                 |  22 +++-
 .../proxy_protocol/proxy_protocol_test.cc     |   8 +-
 test/integration/BUILD                        |  16 +++
 test/integration/cx_limit_integration_test.cc | 106 ++++++++++++++++++
 test/integration/fake_upstream.h              |   8 ++
 test/integration/stats_integration_test.cc    |   2 +-
 test/mocks/network/mocks.h                    |   1 +
 test/mocks/runtime/BUILD                      |   1 +
 test/mocks/runtime/mocks.cc                   |   4 +
 test/server/connection_handler_test.cc        |  89 +++++++++++++++
 test/test_common/logging.cc                   |   4 +
 test/test_common/logging.h                    |   4 +-
 27 files changed, 350 insertions(+), 15 deletions(-)
 create mode 100644 docs/root/configuration/listeners/runtime.rst
 create mode 100644 docs/root/faq/configuration/resource_limits.rst
 create mode 100644 test/integration/cx_limit_integration_test.cc

diff --git a/docs/root/configuration/best_practices/edge.rst b/docs/root/configuration/best_practices/edge.rst
index 0f8b981ab543..ec5c3d5ae707 100644
--- a/docs/root/configuration/best_practices/edge.rst
+++ b/docs/root/configuration/best_practices/edge.rst
@@ -23,6 +23,8 @@ HTTP proxies should additionally configure:
 * :ref:`HTTP/2 maximum concurrent streams limit <envoy_api_field_core.Http2ProtocolOptions.max_concurrent_streams>` to 100,
 * :ref:`HTTP/2 initial stream window size limit <envoy_api_field_core.Http2ProtocolOptions.initial_stream_window_size>` to 64 KiB,
 * :ref:`HTTP/2 initial connection window size limit <envoy_api_field_core.Http2ProtocolOptions.initial_connection_window_size>` to 1 MiB.
+* :ref:`headers_with_underscores_action setting <envoy_api_field_core.HttpProtocolOptions.headers_with_underscores_action>` to REJECT_REQUEST, to protect upstream services that treat '_' and '-' as interchangeable.
+* :ref:`Connection limits. <config_listeners_runtime>`
 
 The following is a YAML example of the above recommendation.
 
@@ -109,3 +111,13 @@ The following is a YAML example of the above recommendation.
       http2_protocol_options:
         initial_stream_window_size: 65536 # 64 KiB
         initial_connection_window_size: 1048576 # 1 MiB
+
+  layered_runtime:
+    layers:
+      - name: static_layer_0
+        static_layer:
+          envoy:
+            resource_limits:
+              listener:
+                example_listener_name:
+                  connection_limit: 10000
diff --git a/docs/root/configuration/listeners/listeners.rst b/docs/root/configuration/listeners/listeners.rst
index 9b3e2161ef0c..5e4cc6b22c5e 100644
--- a/docs/root/configuration/listeners/listeners.rst
+++ b/docs/root/configuration/listeners/listeners.rst
@@ -8,6 +8,7 @@ Listeners
 
   overview
   stats
+  runtime
   listener_filters/listener_filters
   network_filters/network_filters
   udp_filters/udp_filters
diff --git a/docs/root/configuration/listeners/runtime.rst b/docs/root/configuration/listeners/runtime.rst
new file mode 100644
index 000000000000..b42b6aa5fa3f
--- /dev/null
+++ b/docs/root/configuration/listeners/runtime.rst
@@ -0,0 +1,8 @@
+.. _config_listeners_runtime:
+
+Runtime
+-------
+The following runtime settings are supported:
+
+envoy.resource_limits.listener.<name of listener>.connection_limit
+    Sets a limit on the number of active connections to the specified listener.
diff --git a/docs/root/configuration/listeners/stats.rst b/docs/root/configuration/listeners/stats.rst
index 58bc2f57e297..fabfbbf6aa10 100644
--- a/docs/root/configuration/listeners/stats.rst
+++ b/docs/root/configuration/listeners/stats.rst
@@ -16,6 +16,7 @@ Every listener has a statistics tree rooted at *listener.<address>.* with the fo
    downstream_cx_destroy, Counter, Total destroyed connections
    downstream_cx_active, Gauge, Total active connections
    downstream_cx_length_ms, Histogram, Connection length milliseconds
+   downstream_cx_overflow, Counter, Total connections rejected due to enforcement of listener connection limit
    downstream_pre_cx_timeout, Counter, Sockets that timed out during listener filter processing
    downstream_pre_cx_active, Gauge, Sockets currently undergoing listener filter processing
    no_filter_chain_match, Counter, Total connections that didn't match any filter chain
diff --git a/docs/root/faq/configuration/resource_limits.rst b/docs/root/faq/configuration/resource_limits.rst
new file mode 100644
index 000000000000..c20c64929b10
--- /dev/null
+++ b/docs/root/faq/configuration/resource_limits.rst
@@ -0,0 +1,16 @@
+.. _faq_resource_limits:
+
+How does Envoy prevent file descriptor exhaustion?
+==================================================
+
+:ref:`Per-listener connection limits <config_listeners_runtime>` may be configured as an upper bound on
+the number of active connections a particular listener will accept. The listener may accept more
+connections than the configured value on the order of the number of worker threads. On Unix-based
+systems, it is recommended to keep the sum of all connection limits less than half of the system's
+file descriptor limit to account for upstream connections, files, and other usage of file
+descriptors.
+
+.. note::
+
+    This per-listener connection limiting will eventually be handled by the :ref:`overload manager
+    <arch_overview_overload_manager>`.
diff --git a/docs/root/faq/overview.rst b/docs/root/faq/overview.rst
index b64a6769de24..7a344878a127 100644
--- a/docs/root/faq/overview.rst
+++ b/docs/root/faq/overview.rst
@@ -33,6 +33,7 @@ Configuration
   configuration/zipkin_tracing
   configuration/flow_control
   configuration/timeouts
+  configuration/resource_limits
 
 Load balancing
 --------------
diff --git a/docs/root/intro/version_history.rst b/docs/root/intro/version_history.rst
index d7e03c04e400..cf2f6300dbda 100644
--- a/docs/root/intro/version_history.rst
+++ b/docs/root/intro/version_history.rst
@@ -3,6 +3,7 @@ Version history
 
 1.13.3 (Pending)
 ================
+* listener: add runtime support for `per-listener limits <config_listeners_runtime>` on active/accepted connections.
 
 1.13.2 (June 8, 2020)
 =====================
diff --git a/examples/front-proxy/front-envoy.yaml b/examples/front-proxy/front-envoy.yaml
index 5bed8c849017..e19e6109b28e 100644
--- a/examples/front-proxy/front-envoy.yaml
+++ b/examples/front-proxy/front-envoy.yaml
@@ -4,6 +4,7 @@ static_resources:
       socket_address:
         address: 0.0.0.0
         port_value: 80
+    name: example_listener_name
     filter_chains:
     - filters:
       - name: envoy.http_connection_manager
@@ -64,3 +65,12 @@ admin:
     socket_address:
       address: 0.0.0.0
       port_value: 8001
+layered_runtime:
+  layers:
+    - name: static_layer_0
+      static_layer:
+        envoy:
+          resource_limits:
+            listener:
+              example_listener_name:
+                connection_limit: 10000
diff --git a/include/envoy/network/listener.h b/include/envoy/network/listener.h
index e633402e7fda..cb887780fed1 100644
--- a/include/envoy/network/listener.h
+++ b/include/envoy/network/listener.h
@@ -6,6 +6,7 @@
 
 #include "envoy/api/io_error.h"
 #include "envoy/common/exception.h"
+#include "envoy/common/resource.h"
 #include "envoy/config/core/v3/base.pb.h"
 #include "envoy/network/connection.h"
 #include "envoy/network/connection_balancer.h"
@@ -142,6 +143,11 @@ public:
    *         though the implementation may be a NOP balancer.
    */
   virtual ConnectionBalancer& connectionBalancer() PURE;
+
+  /**
+   * Open connection resources for this listener.
+   */
+  virtual ResourceLimit& openConnections() PURE;
 };
 
 /**
diff --git a/source/common/upstream/resource_manager_impl.h b/source/common/upstream/resource_manager_impl.h
index e13e16d9a5fa..9f8db3b2c596 100644
--- a/source/common/upstream/resource_manager_impl.h
+++ b/source/common/upstream/resource_manager_impl.h
@@ -61,13 +61,14 @@ private:
       remaining_.set(max);
     }
 
-    // Upstream::Resource
-    bool canCreate() override { return current_ < max(); }
+    ~ManagedResourceImpl() override { ASSERT(count() == 0); }
+
     void inc() override {
       BasicResourceLimitImpl::inc();
       updateRemaining();
       open_gauge_.set(BasicResourceLimitImpl::canCreate() ? 0 : 1);
     }
+
     void decBy(uint64_t amount) override {
       BasicResourceLimitImpl::decBy(amount);
       updateRemaining();
diff --git a/source/server/connection_handler_impl.cc b/source/server/connection_handler_impl.cc
index fec70ae19b4a..9f0c188bf162 100644
--- a/source/server/connection_handler_impl.cc
+++ b/source/server/connection_handler_impl.cc
@@ -292,6 +292,14 @@ void ConnectionHandlerImpl::ActiveTcpSocket::newConnection() {
 }
 
 void ConnectionHandlerImpl::ActiveTcpListener::onAccept(Network::ConnectionSocketPtr&& socket) {
+  if (listenerConnectionLimitReached()) {
+    ENVOY_LOG(trace, "closing connection: listener connection limit reached for {}",
+              config_.name());
+    socket->close();
+    stats_.downstream_cx_overflow_.inc();
+    return;
+  }
+
   onAcceptWorker(std::move(socket), config_.handOffRestoredDestinationConnections(), false);
 }
 
diff --git a/source/server/connection_handler_impl.h b/source/server/connection_handler_impl.h
index 10a0d7340d4f..66c65d67958a 100644
--- a/source/server/connection_handler_impl.h
+++ b/source/server/connection_handler_impl.h
@@ -28,6 +28,7 @@ namespace Server {
 #define ALL_LISTENER_STATS(COUNTER, GAUGE, HISTOGRAM)                                              \
   COUNTER(downstream_cx_destroy)                                                                   \
   COUNTER(downstream_cx_total)                                                                     \
+  COUNTER(downstream_cx_overflow)                                                                  \
   COUNTER(downstream_pre_cx_timeout)                                                               \
   COUNTER(no_filter_chain_match)                                                                   \
   GAUGE(downstream_cx_active, Accumulate)                                                          \
@@ -108,11 +109,17 @@ private:
     ActiveTcpListener(ConnectionHandlerImpl& parent, Network::ListenerPtr&& listener,
                       Network::ListenerConfig& config);
     ~ActiveTcpListener() override;
+    bool listenerConnectionLimitReached() const {
+      // TODO(tonya11en): Delegate enforcement of per-listener connection limits to overload
+      // manager.
+      return !config_.openConnections().canCreate();
+    }
     void onAcceptWorker(Network::ConnectionSocketPtr&& socket,
                         bool hand_off_restored_destination_connections, bool rebalanced);
     void decNumConnections() {
       ASSERT(num_listener_connections_ > 0);
       --num_listener_connections_;
+      config_.openConnections().dec();
     }
 
     // Network::ListenerCallbacks
@@ -124,7 +131,10 @@ private:
 
     // Network::BalancedConnectionHandler
     uint64_t numConnections() const override { return num_listener_connections_; }
-    void incNumConnections() override { ++num_listener_connections_; }
+    void incNumConnections() override {
+      ++num_listener_connections_;
+      config_.openConnections().inc();
+    }
     void post(Network::ConnectionSocketPtr&& socket) override;
 
     /**
diff --git a/source/server/http/BUILD b/source/server/http/BUILD
index 303ee872af31..8d081cc99af4 100644
--- a/source/server/http/BUILD
+++ b/source/server/http/BUILD
@@ -32,6 +32,7 @@ envoy_cc_library(
         "//source/common/access_log:access_log_lib",
         "//source/common/buffer:buffer_lib",
         "//source/common/common:assert_lib",
+        "//source/common/common:basic_resource_lib",
         "//source/common/common:empty_string",
         "//source/common/common:enum_to_int",
         "//source/common/common:macros",
diff --git a/source/server/http/admin.h b/source/server/http/admin.h
index ed14dc49bf42..fbd854445887 100644
--- a/source/server/http/admin.h
+++ b/source/server/http/admin.h
@@ -23,6 +23,7 @@
 #include "envoy/upstream/outlier_detection.h"
 #include "envoy/upstream/resource_manager.h"
 
+#include "common/common/basic_resource_impl.h"
 #include "common/common/empty_string.h"
 #include "common/common/logger.h"
 #include "common/common/macros.h"
@@ -404,12 +405,14 @@ private:
       return envoy::config::core::v3::UNSPECIFIED;
     }
     Network::ConnectionBalancer& connectionBalancer() override { return connection_balancer_; }
+    ResourceLimit& openConnections() override { return open_connections_; }
 
     AdminImpl& parent_;
     const std::string name_;
     Stats::ScopePtr scope_;
     Http::ConnectionManagerListenerStats stats_;
     Network::NopConnectionBalancerImpl connection_balancer_;
+    BasicResourceLimitImpl open_connections_;
   };
   using AdminListenerPtr = std::unique_ptr<AdminListener>;
 
diff --git a/source/server/listener_impl.cc b/source/server/listener_impl.cc
index f89aef98bc5d..74998b38adc3 100644
--- a/source/server/listener_impl.cc
+++ b/source/server/listener_impl.cc
@@ -147,7 +147,11 @@ ListenerImpl::ListenerImpl(const envoy::config::listener::v3::Listener& config,
       config_(config), version_info_(version_info),
       listener_filters_timeout_(
           PROTOBUF_GET_MS_OR_DEFAULT(config, listener_filters_timeout, 15000)),
-      continue_on_listener_filters_timeout_(config.continue_on_listener_filters_timeout()) {
+      continue_on_listener_filters_timeout_(config.continue_on_listener_filters_timeout()),
+      cx_limit_runtime_key_("envoy.resource_limits.listener." + config_.name() +
+                            ".connection_limit"),
+      open_connections_(std::make_shared<BasicResourceLimitImpl>(
+          std::numeric_limits<uint64_t>::max(), parent.server_.runtime(), cx_limit_runtime_key_)) {
   Network::Address::SocketType socket_type =
       Network::Utility::protobufAddressSocketType(config.address());
   if (PROTOBUF_GET_WRAPPED_OR_DEFAULT(config, transparent, false)) {
@@ -183,6 +187,15 @@ ListenerImpl::ListenerImpl(const envoy::config::listener::v3::Listener& config,
     udp_listener_factory_ = config_factory.createActiveUdpListenerFactory(*message);
   }
 
+  const absl::optional<std::string> runtime_val =
+      parent_.server_.runtime().snapshot().get(cx_limit_runtime_key_);
+  if (runtime_val && runtime_val->empty()) {
+    ENVOY_LOG(warn,
+              "Listener connection limit runtime key {} is empty. There are currently no "
+              "limitations on the number of accepted connections for listener {}.",
+              cx_limit_runtime_key_, config_.name());
+  }
+
   if (!config.listener_filters().empty()) {
     switch (socket_type) {
     case Network::Address::SocketType::Datagram:
diff --git a/source/server/listener_impl.h b/source/server/listener_impl.h
index 446e7f73218d..4a9c2d43b0f3 100644
--- a/source/server/listener_impl.h
+++ b/source/server/listener_impl.h
@@ -10,6 +10,7 @@
 #include "envoy/server/listener_manager.h"
 #include "envoy/stats/scope.h"
 
+#include "common/common/basic_resource_impl.h"
 #include "common/common/logger.h"
 #include "common/init/manager_impl.h"
 
@@ -150,6 +151,14 @@ public:
     return udp_listener_factory_.get();
   }
   Network::ConnectionBalancer& connectionBalancer() override { return *connection_balancer_; }
+  ResourceLimit& openConnections() override { return *open_connections_; }
+
+  void ensureSocketOptions() {
+    if (!listen_socket_options_) {
+      listen_socket_options_ =
+          std::make_shared<std::vector<Network::Socket::OptionConstSharedPtr>>();
+    }
+  }
 
   // Server::Configuration::ListenerFactoryContext
   AccessLog::AccessLogManager& accessLogManager() override;
@@ -179,12 +188,6 @@ public:
   OptProcessContextRef processContext() override;
   Configuration::ServerFactoryContext& getServerFactoryContext() const override;
 
-  void ensureSocketOptions() {
-    if (!listen_socket_options_) {
-      listen_socket_options_ =
-          std::make_shared<std::vector<Network::Socket::OptionConstSharedPtr>>();
-    }
-  }
   // Network::DrainDecision
   bool drainClose() const override;
 
@@ -202,6 +205,7 @@ private:
     ensureSocketOptions();
     listen_socket_options_->emplace_back(std::move(option));
   }
+
   void addListenSocketOptions(const Network::Socket::OptionsSharedPtr& options) {
     ensureSocketOptions();
     Network::Socket::appendOptions(listen_socket_options_, options);
@@ -243,6 +247,12 @@ private:
   Network::ActiveUdpListenerFactoryPtr udp_listener_factory_;
   Network::ConnectionBalancerPtr connection_balancer_;
 
+  // Per-listener connection limits are only specified via runtime.
+  //
+  // TODO (tonya11en): Move this functionality into the overload manager.
+  const std::string cx_limit_runtime_key_;
+  std::shared_ptr<BasicResourceLimitImpl> open_connections_;
+
   // to access ListenerManagerImpl::factory_.
   friend class ListenerFilterChainFactoryBuilder;
 };
diff --git a/test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc b/test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc
index 060e9c26f6b8..e3e02030656a 100644
--- a/test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc
+++ b/test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc
@@ -81,6 +81,7 @@ public:
   bool continueOnListenerFiltersTimeout() const override { return false; }
   Stats::Scope& listenerScope() override { return stats_store_; }
   uint64_t listenerTag() const override { return 1; }
+  ResourceLimit& openConnections() override { return open_connections_; }
   const std::string& name() const override { return name_; }
   const Network::ActiveUdpListenerFactory* udpListenerFactory() override { return nullptr; }
   envoy::config::core::v3::TrafficDirection direction() const override {
@@ -179,6 +180,7 @@ public:
   NiceMock<Network::MockConnectionCallbacks> connection_callbacks_;
   Network::Connection* server_connection_;
   Network::MockConnectionCallbacks server_callbacks_;
+  BasicResourceLimitImpl open_connections_;
   std::shared_ptr<Network::MockReadFilter> read_filter_;
   std::string name_;
   const Network::FilterChainSharedPtr filter_chain_;
@@ -939,9 +941,8 @@ public:
   bool bindToPort() override { return true; }
   bool handOffRestoredDestinationConnections() const override { return false; }
   uint32_t perConnectionBufferLimitBytes() const override { return 0; }
-  std::chrono::milliseconds listenerFiltersTimeout() const override {
-    return std::chrono::milliseconds();
-  }
+  std::chrono::milliseconds listenerFiltersTimeout() const override { return {}; }
+  ResourceLimit& openConnections() override { return open_connections_; }
   bool continueOnListenerFiltersTimeout() const override { return false; }
   Stats::Scope& listenerScope() override { return stats_store_; }
   uint64_t listenerTag() const override { return 1; }
@@ -1003,6 +1004,7 @@ public:
   Stats::IsolatedStoreImpl stats_store_;
   Api::ApiPtr api_;
   Event::DispatcherPtr dispatcher_;
+  BasicResourceLimitImpl open_connections_;
   Network::MockListenSocketFactory socket_factory_;
   std::shared_ptr<Network::TcpListenSocket> socket_;
   Network::Address::InstanceConstSharedPtr local_dst_address_;
diff --git a/test/integration/BUILD b/test/integration/BUILD
index d325d656a153..c360a695232f 100644
--- a/test/integration/BUILD
+++ b/test/integration/BUILD
@@ -517,6 +517,7 @@ envoy_cc_test_library(
         "//source/common/buffer:buffer_lib",
         "//source/common/buffer:zero_copy_input_stream_lib",
         "//source/common/common:assert_lib",
+        "//source/common/common:basic_resource_lib",
         "//source/common/common:minimal_logger_lib",
         "//source/common/config:api_version_lib",
         "//source/common/config:version_converter_lib",
@@ -1032,3 +1033,18 @@ envoy_cc_test(
         "//test/test_common:utility_lib",
     ],
 )
+
+envoy_cc_test(
+    name = "cx_limit_integration_test",
+    srcs = ["cx_limit_integration_test.cc"],
+    deps = [
+        ":http_integration_lib",
+        "//include/envoy/network:filter_interface",
+        "//include/envoy/registry",
+        "//source/extensions/filters/network/tcp_proxy:config",
+        "//test/config:utility_lib",
+        "//test/test_common:logging_lib",
+        "//test/test_common:simulated_time_system_lib",
+        "@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto",
+    ],
+)
diff --git a/test/integration/cx_limit_integration_test.cc b/test/integration/cx_limit_integration_test.cc
new file mode 100644
index 000000000000..53cded44784d
--- /dev/null
+++ b/test/integration/cx_limit_integration_test.cc
@@ -0,0 +1,106 @@
+#include "envoy/config/bootstrap/v3/bootstrap.pb.h"
+#include "envoy/network/filter.h"
+#include "envoy/registry/registry.h"
+
+#include "common/network/utility.h"
+
+#include "test/config/utility.h"
+#include "test/integration/integration.h"
+#include "test/test_common/logging.h"
+#include "test/test_common/simulated_time_system.h"
+
+#include "gtest/gtest.h"
+
+namespace Envoy {
+namespace {
+
+class ConnectionLimitIntegrationTest : public testing::TestWithParam<Network::Address::IpVersion>,
+                                       public Event::TestUsingSimulatedTime,
+                                       public BaseIntegrationTest {
+public:
+  ConnectionLimitIntegrationTest()
+      : BaseIntegrationTest(GetParam(), ConfigHelper::TCP_PROXY_CONFIG) {}
+
+  void setEmptyListenerLimit() {
+    config_helper_.addRuntimeOverride("envoy.resource_limits.listener.listener_0.connection_limit",
+                                      "");
+  }
+
+  void setListenerLimit(const uint32_t num_conns) {
+    config_helper_.addRuntimeOverride("envoy.resource_limits.listener.listener_0.connection_limit",
+                                      std::to_string(num_conns));
+  }
+
+  void initialize() override { BaseIntegrationTest::initialize(); }
+};
+
+INSTANTIATE_TEST_SUITE_P(IpVersions, ConnectionLimitIntegrationTest,
+                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
+                         TestUtility::ipTestParamsToString);
+
+TEST_P(ConnectionLimitIntegrationTest, TestListenerLimit) {
+  setListenerLimit(2);
+  initialize();
+
+  std::vector<IntegrationTcpClientPtr> tcp_clients;
+  std::vector<FakeRawConnectionPtr> raw_conns;
+
+  tcp_clients.emplace_back(makeTcpConnection(lookupPort("listener_0")));
+  raw_conns.emplace_back();
+  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(raw_conns.back()));
+  ASSERT_TRUE(tcp_clients.back()->connected());
+
+  tcp_clients.emplace_back(makeTcpConnection(lookupPort("listener_0")));
+  raw_conns.emplace_back();
+  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(raw_conns.back()));
+  ASSERT_TRUE(tcp_clients.back()->connected());
+
+  tcp_clients.emplace_back(makeTcpConnection(lookupPort("listener_0")));
+  raw_conns.emplace_back();
+  ASSERT_FALSE(fake_upstreams_[0]->waitForRawConnection(raw_conns.back()));
+  tcp_clients.back()->waitForDisconnect();
+
+  // Get rid of the client that failed to connect.
+  tcp_clients.back()->close();
+  tcp_clients.pop_back();
+
+  // Close the first connection that was successful so that we can open a new successful connection.
+  tcp_clients.front()->close();
+  ASSERT_TRUE(raw_conns.front()->close());
+  ASSERT_TRUE(raw_conns.front()->waitForDisconnect());
+
+  tcp_clients.emplace_back(makeTcpConnection(lookupPort("listener_0")));
+  raw_conns.emplace_back();
+  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(raw_conns.back()));
+  ASSERT_TRUE(tcp_clients.back()->connected());
+
+  const bool isV4 = (version_ == Network::Address::IpVersion::v4);
+  auto local_address = isV4 ? Network::Utility::getCanonicalIpv4LoopbackAddress()
+                            : Network::Utility::getIpv6LoopbackAddress();
+
+  const std::string counter_name = isV4 ? ("listener.127.0.0.1_0.downstream_cx_overflow")
+                                        : ("listener.[__1]_0.downstream_cx_overflow");
+
+  test_server_->waitForCounterEq(counter_name, 1);
+
+  for (auto& tcp_client : tcp_clients) {
+    tcp_client->close();
+  }
+
+  tcp_clients.clear();
+  raw_conns.clear();
+}
+
+TEST_P(ConnectionLimitIntegrationTest, TestEmptyListenerRuntimeLimit) {
+  const std::string log_line =
+      "Listener connection limit runtime key "
+      "envoy.resource_limits.listener.listener_0.connection_limit is empty. There are currently "
+      "no limitations on the number of accepted connections for listener listener_0.";
+  EXPECT_LOG_CONTAINS("warn", log_line, {
+    setEmptyListenerLimit();
+    initialize();
+  });
+}
+
+} // namespace
+} // namespace Envoy
diff --git a/test/integration/fake_upstream.h b/test/integration/fake_upstream.h
index 551aa25aef61..82d20a2d1e78 100644
--- a/test/integration/fake_upstream.h
+++ b/test/integration/fake_upstream.h
@@ -19,6 +19,7 @@
 
 #include "common/buffer/buffer_impl.h"
 #include "common/buffer/zero_copy_input_stream_impl.h"
+#include "common/common/basic_resource_impl.h"
 #include "common/common/callback_impl.h"
 #include "common/common/linked_object.h"
 #include "common/common/lock_guard.h"
@@ -684,11 +685,18 @@ private:
     envoy::config::core::v3::TrafficDirection direction() const override {
       return envoy::config::core::v3::UNSPECIFIED;
     }
+    ResourceLimit& openConnections() override { return connection_resource_; }
+
+    void setMaxConnections(const uint32_t num_connections) {
+      connection_resource_.setMax(num_connections);
+    }
+    void clearMaxConnections() { connection_resource_.resetMax(); }
 
     FakeUpstream& parent_;
     const std::string name_;
     Network::NopConnectionBalancerImpl connection_balancer_;
     const Network::ActiveUdpListenerFactoryPtr udp_listener_factory_;
+    BasicResourceLimitImpl connection_resource_;
   };
 
   void threadRoutine();
diff --git a/test/integration/stats_integration_test.cc b/test/integration/stats_integration_test.cc
index aecaf6b2052d..1a37ab90a993 100644
--- a/test/integration/stats_integration_test.cc
+++ b/test/integration/stats_integration_test.cc
@@ -341,7 +341,7 @@ TEST_P(ClusterMemoryTestRunner, MemoryLargeClusterSizeWithRealSymbolTable) {
   // https://github.com/envoyproxy/envoy/blob/master/source/docs/stats.md#stats-memory-tests
   // for details on how to fix.
   EXPECT_MEMORY_EQ(m_per_cluster, 36124);
-  EXPECT_MEMORY_LE(m_per_cluster, 36800);
+  EXPECT_MEMORY_LE(m_per_cluster, 37000);
 }
 
 TEST_P(ClusterMemoryTestRunner, MemoryLargeHostSizeWithStats) {
diff --git a/test/mocks/network/mocks.h b/test/mocks/network/mocks.h
index f31dd1627a54..39a3bcc28870 100644
--- a/test/mocks/network/mocks.h
+++ b/test/mocks/network/mocks.h
@@ -315,6 +315,7 @@ public:
   MOCK_CONST_METHOD0(name, const std::string&());
   MOCK_METHOD0(udpListenerFactory, const Network::ActiveUdpListenerFactory*());
   MOCK_METHOD0(connectionBalancer, ConnectionBalancer&());
+  MOCK_METHOD0(openConnections, ResourceLimit&());
 
   envoy::config::core::v3::TrafficDirection direction() const override {
     return envoy::config::core::v3::UNSPECIFIED;
diff --git a/test/mocks/runtime/BUILD b/test/mocks/runtime/BUILD
index 7d899cb90c58..1ff97b2e9ac9 100644
--- a/test/mocks/runtime/BUILD
+++ b/test/mocks/runtime/BUILD
@@ -16,6 +16,7 @@ envoy_cc_mock(
     deps = [
         "//include/envoy/runtime:runtime_interface",
         "//include/envoy/upstream:cluster_manager_interface",
+        "//source/common/common:empty_string",
         "//test/mocks:common_lib",
         "@envoy_api//envoy/type/v3:pkg_cc_proto",
     ],
diff --git a/test/mocks/runtime/mocks.cc b/test/mocks/runtime/mocks.cc
index 330c4a53d22b..5e0aa26544bd 100644
--- a/test/mocks/runtime/mocks.cc
+++ b/test/mocks/runtime/mocks.cc
@@ -1,11 +1,14 @@
 #include "mocks.h"
 
+#include "common/common/empty_string.h"
+
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 
 using testing::_;
 using testing::Return;
 using testing::ReturnArg;
+using testing::ReturnRef;
 
 namespace Envoy {
 namespace Runtime {
@@ -19,6 +22,7 @@ MockSnapshot::MockSnapshot() {
   ON_CALL(*this, getDouble(_, _)).WillByDefault(ReturnArg<1>());
   ON_CALL(*this, getBoolean(_, _)).WillByDefault(ReturnArg<1>());
   ON_CALL(*this, exists(_)).WillByDefault(Return(false));
+  ON_CALL(*this, get(_)).WillByDefault(ReturnRef(EMPTY_STRING));
 }
 
 MockSnapshot::~MockSnapshot() = default;
diff --git a/test/server/connection_handler_test.cc b/test/server/connection_handler_test.cc
index ec4fcf68b5c2..dafbcd5bb2f1 100644
--- a/test/server/connection_handler_test.cc
+++ b/test/server/connection_handler_test.cc
@@ -91,6 +91,12 @@ public:
       return envoy::config::core::v3::UNSPECIFIED;
     }
     Network::ConnectionBalancer& connectionBalancer() override { return *connection_balancer_; }
+    ResourceLimit& openConnections() override { return open_connections_; }
+
+    void setMaxConnections(const uint32_t num_connections) {
+      open_connections_.setMax(num_connections);
+    }
+    void clearMaxConnections() { open_connections_.resetMax(); }
 
     ConnectionHandlerTest& parent_;
     std::shared_ptr<Network::MockListenSocket> socket_;
@@ -103,6 +109,7 @@ public:
     const bool continue_on_listener_filters_timeout_;
     std::unique_ptr<Network::ActiveUdpListenerFactory> udp_listener_factory_;
     Network::ConnectionBalancerPtr connection_balancer_;
+    BasicResourceLimitImpl open_connections_;
   };
 
   using TestListenerPtr = std::unique_ptr<TestListener>;
@@ -207,6 +214,88 @@ TEST_F(ConnectionHandlerTest, RemoveListenerDuringRebalance) {
 #endif
 }
 
+TEST_F(ConnectionHandlerTest, ListenerConnectionLimitEnforced) {
+  Network::ListenerCallbacks* listener_callbacks1;
+  auto listener1 = new NiceMock<Network::MockListener>();
+  TestListener* test_listener1 =
+      addListener(1, false, false, "test_listener1", listener1, &listener_callbacks1);
+  Network::Address::InstanceConstSharedPtr normal_address(
+      new Network::Address::Ipv4Instance("127.0.0.1", 10001));
+  EXPECT_CALL(*socket_factory_, localAddress()).WillRepeatedly(ReturnRef(normal_address));
+  // Only allow a single connection on this listener.
+  test_listener1->setMaxConnections(1);
+  handler_->addListener(*test_listener1);
+
+  auto listener2 = new NiceMock<Network::MockListener>();
+  Network::ListenerCallbacks* listener_callbacks2;
+  TestListener* test_listener2 =
+      addListener(2, false, false, "test_listener2", listener2, &listener_callbacks2);
+  Network::Address::InstanceConstSharedPtr alt_address(
+      new Network::Address::Ipv4Instance("127.0.0.2", 20002));
+  EXPECT_CALL(*socket_factory_, localAddress()).WillRepeatedly(ReturnRef(alt_address));
+  // Do not allow any connections on this listener.
+  test_listener2->setMaxConnections(0);
+  handler_->addListener(*test_listener2);
+
+  EXPECT_CALL(manager_, findFilterChain(_)).WillRepeatedly(Return(filter_chain_.get()));
+  EXPECT_CALL(factory_, createNetworkFilterChain(_, _)).WillRepeatedly(Return(true));
+  Network::MockListenerFilter* test_filter = new Network::MockListenerFilter();
+  EXPECT_CALL(*test_filter, destroy_());
+  EXPECT_CALL(factory_, createListenerFilterChain(_))
+      .WillRepeatedly(Invoke([&](Network::ListenerFilterManager& manager) -> bool {
+        manager.addAcceptFilter(Network::ListenerFilterPtr{test_filter});
+        return true;
+      }));
+  EXPECT_CALL(*test_filter, onAccept(_))
+      .WillRepeatedly(Invoke([&](Network::ListenerFilterCallbacks&) -> Network::FilterStatus {
+        return Network::FilterStatus::Continue;
+      }));
+
+  // For listener 2, verify its connection limit is independent of listener 1.
+
+  // We expect that listener 2 accepts the connection, so there will be a call to
+  // createServerConnection and active cx should increase, while cx overflow remains the same.
+  listener_callbacks2->onAccept(
+      Network::ConnectionSocketPtr{new NiceMock<Network::MockConnectionSocket>()});
+  EXPECT_EQ(0, handler_->numConnections());
+  EXPECT_EQ(0, TestUtility::findCounter(stats_store_, "downstream_cx_total")->value());
+  EXPECT_EQ(0, TestUtility::findGauge(stats_store_, "downstream_cx_active")->value());
+  EXPECT_EQ(1, TestUtility::findCounter(stats_store_, "downstream_cx_overflow")->value());
+
+  // For listener 1, verify connections are limited after one goes active.
+
+  // First connection attempt should result in an active connection being created.
+  auto conn1 = new NiceMock<Network::MockConnection>();
+  EXPECT_CALL(dispatcher_, createServerConnection_()).WillOnce(Return(conn1));
+  listener_callbacks1->onAccept(
+      Network::ConnectionSocketPtr{new NiceMock<Network::MockConnectionSocket>()});
+  EXPECT_EQ(1, handler_->numConnections());
+  // Note that these stats are not the per-worker stats, but the per-listener stats.
+  EXPECT_EQ(1, TestUtility::findCounter(stats_store_, "downstream_cx_total")->value());
+  EXPECT_EQ(1, TestUtility::findGauge(stats_store_, "downstream_cx_active")->value());
+  EXPECT_EQ(1, TestUtility::findCounter(stats_store_, "downstream_cx_overflow")->value());
+
+  // Don't expect server connection to be created, should be instantly closed and increment
+  // overflow stat.
+  listener_callbacks1->onAccept(
+      Network::ConnectionSocketPtr{new NiceMock<Network::MockConnectionSocket>()});
+  EXPECT_EQ(1, handler_->numConnections());
+  EXPECT_EQ(1, TestUtility::findCounter(stats_store_, "downstream_cx_total")->value());
+  EXPECT_EQ(1, TestUtility::findGauge(stats_store_, "downstream_cx_active")->value());
+  EXPECT_EQ(2, TestUtility::findCounter(stats_store_, "downstream_cx_overflow")->value());
+
+  // Check behavior again for good measure.
+  listener_callbacks1->onAccept(
+      Network::ConnectionSocketPtr{new NiceMock<Network::MockConnectionSocket>()});
+  EXPECT_EQ(1, handler_->numConnections());
+  EXPECT_EQ(1, TestUtility::findCounter(stats_store_, "downstream_cx_total")->value());
+  EXPECT_EQ(1, TestUtility::findGauge(stats_store_, "downstream_cx_active")->value());
+  EXPECT_EQ(3, TestUtility::findCounter(stats_store_, "downstream_cx_overflow")->value());
+
+  EXPECT_CALL(*listener1, onDestroy());
+  EXPECT_CALL(*listener2, onDestroy());
+}
+
 TEST_F(ConnectionHandlerTest, RemoveListener) {
   InSequence s;
 
diff --git a/test/test_common/logging.cc b/test/test_common/logging.cc
index 30da5cfacaef..ba604854777c 100644
--- a/test/test_common/logging.cc
+++ b/test/test_common/logging.cc
@@ -2,6 +2,8 @@
 
 #include "common/common/assert.h"
 
+#include "absl/synchronization/mutex.h"
+
 namespace Envoy {
 
 LogLevelSetter::LogLevelSetter(spdlog::level::level_enum log_level) {
@@ -27,6 +29,8 @@ LogRecordingSink::~LogRecordingSink() = default;
 
 void LogRecordingSink::log(absl::string_view msg) {
   previous_delegate()->log(msg);
+
+  absl::MutexLock ml(&mtx_);
   messages_.push_back(std::string(msg));
 }
 
diff --git a/test/test_common/logging.h b/test/test_common/logging.h
index e9cb6e42dd87..c363d2c95c8d 100644
--- a/test/test_common/logging.h
+++ b/test/test_common/logging.h
@@ -8,6 +8,7 @@
 
 #include "absl/strings/str_join.h"
 #include "absl/strings/str_split.h"
+#include "absl/synchronization/mutex.h"
 #include "spdlog/spdlog.h"
 
 namespace Envoy {
@@ -58,7 +59,8 @@ public:
   const std::vector<std::string>& messages() const { return messages_; }
 
 private:
-  std::vector<std::string> messages_;
+  absl::Mutex mtx_;
+  std::vector<std::string> messages_ ABSL_GUARDED_BY(mtx_);
 };
 
 using StringPair = std::pair<std::string, std::string>;
-- 
2.26.2

