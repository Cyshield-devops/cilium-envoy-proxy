From 3e49834ab1907f8f109b7ce197721b7c7e37611b Mon Sep 17 00:00:00 2001
From: Asra Ali <asraa@google.com>
Date: Tue, 24 Sep 2019 10:55:14 -0400
Subject: [PATCH] Add configurable limit for the number of headers

Signed-off-by: Asra Ali <asraa@google.com>
---
 api/envoy/api/v2/cds.proto                    |    4 +-
 api/envoy/api/v2/core/protocol.proto          |   14 +-
 .../v2/http_connection_manager.proto          |   15 +-
 docs/root/intro/version_history.rst           |   11 +-
 include/envoy/http/codec.h                    |    7 +
 include/envoy/upstream/upstream.h             |    6 +
 source/common/http/codec_client.cc            |    5 +-
 source/common/http/conn_manager_config.h      |    5 +
 source/common/http/conn_manager_utility.cc    |   10 +-
 source/common/http/conn_manager_utility.h     |    2 +-
 source/common/http/http1/codec_impl.cc        |   23 +-
 source/common/http/http1/codec_impl.h         |   11 +-
 source/common/http/http2/codec_impl.cc        |   21 +-
 source/common/http/http2/codec_impl.h         |   12 +-
 source/common/upstream/BUILD                  |    1 +
 source/common/upstream/upstream_impl.cc       |    6 +
 source/common/upstream/upstream_impl.h        |    2 +
 .../network/http_connection_manager/BUILD     |    1 +
 .../network/http_connection_manager/config.cc |   24 +-
 .../network/http_connection_manager/config.h  |    2 +
 source/server/http/admin.cc                   |    2 +-
 source/server/http/admin.h                    |    2 +
 test/common/http/codec_impl_fuzz_test.cc      |   20 +-
 .../http/conn_manager_impl_fuzz_test.cc       |    2 +
 test/common/http/conn_manager_impl_test.cc    |    2 +
 test/common/http/conn_manager_utility_test.cc |    1 +
 test/common/http/http1/codec_impl_test.cc     |  181 ++-
 test/common/http/http2/codec_impl_test.cc     |   88 +-
 test/common/http/http2/codec_impl_test_util.h |   12 +-
 test/common/http/http2/frame_replay.cc        |   12 +-
 .../http_connection_manager/config_test.cc    |   69 ++
 test/integration/#http_integration.cc#        | 1048 +++++++++++++++++
 test/integration/autonomous_upstream.cc       |    2 +-
 test/integration/fake_upstream.cc             |   18 +-
 test/integration/fake_upstream.h              |    6 +-
 .../http2_upstream_integration_test.cc        |   63 +
 .../http2_upstream_integration_test.h         |    2 +
 test/integration/http_integration.cc          |   36 +-
 test/integration/http_integration.h           |    4 +-
 test/integration/protocol_integration_test.cc |   84 +-
 test/mocks/upstream/cluster_info.cc           |    2 +
 test/mocks/upstream/cluster_info.h            |    2 +
 42 files changed, 1681 insertions(+), 159 deletions(-)
 create mode 100644 test/integration/#http_integration.cc#

diff --git a/api/envoy/api/v2/cds.proto b/api/envoy/api/v2/cds.proto
index 83fe4329e..dc0e25b80 100644
--- a/api/envoy/api/v2/cds.proto
+++ b/api/envoy/api/v2/cds.proto
@@ -233,8 +233,8 @@ message Cluster {
 
   reserved 12;
 
-  // Additional options when handling HTTP requests. These options will be applicable to both
-  // HTTP1 and HTTP2 requests.
+  // Additional options when handling HTTP requests upstream. These options will be applicable to
+  // both HTTP1 and HTTP2 requests.
   core.HttpProtocolOptions common_http_protocol_options = 29;
 
   // Additional options when handling HTTP1 requests.
diff --git a/api/envoy/api/v2/core/protocol.proto b/api/envoy/api/v2/core/protocol.proto
index 88a82077a..ed751dc67 100644
--- a/api/envoy/api/v2/core/protocol.proto
+++ b/api/envoy/api/v2/core/protocol.proto
@@ -23,11 +23,19 @@ message TcpProtocolOptions {
 }
 
 message HttpProtocolOptions {
-  // The idle timeout for upstream connection pool connections. The idle timeout is defined as the
+  // The idle timeout for connections. The idle timeout is defined as the
   // period in which there are no active requests. If not set, there is no idle timeout. When the
-  // idle timeout is reached the connection will be closed. Note that request based timeouts mean
-  // that HTTP/2 PINGs will not keep the connection alive.
+  // idle timeout is reached the connection will be closed. If the connection is an HTTP/2
+  // downstream connection a drain sequence will occur prior to closing the connection, see
+  // :ref:`drain_timeout
+  // <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.drain_timeout>`.
+  // Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
   google.protobuf.Duration idle_timeout = 1 [(gogoproto.stdduration) = true];
+
+  // The maximum number of headers. If unconfigured, the default
+  // maximum number of request headers allowed is 100. Requests that exceed this limit will receive
+  // a 431 response for HTTP/1.x and cause a stream reset for HTTP/2.
+  google.protobuf.UInt32Value max_headers_count = 2 [(validate.rules).uint32 = {gte: 1}];
 }
 
 message Http1ProtocolOptions {
diff --git a/api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto b/api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto
index f0c7b0f59..ef486f848 100644
--- a/api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto
+++ b/api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto
@@ -25,7 +25,7 @@ import "gogoproto/gogo.proto";
 // [#protodoc-title: HTTP connection manager]
 // HTTP connection manager :ref:`configuration overview <config_http_conn_man>`.
 
-// [#comment:next free field: 33]
+// [#comment:next free field: 36]
 message HttpConnectionManager {
   enum CodecType {
     option (gogoproto.goproto_enum_prefix) = false;
@@ -133,6 +133,10 @@ message HttpConnectionManager {
   // <envoy_api_msg_config.trace.v2.Tracing>`.
   Tracing tracing = 7;
 
+  // Additional settings for HTTP requests handled by the connection manager. These will be
+  // applicable to both HTTP1 and HTTP2 requests.
+  envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 35;
+
   // Additional HTTP/1 settings that are passed to the HTTP/1 codec.
   envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 8;
 
@@ -155,10 +159,11 @@ message HttpConnectionManager {
   // idle timeout is defined as the period in which there are no active
   // requests. If not set, there is no idle timeout. When the idle timeout is
   // reached the connection will be closed. If the connection is an HTTP/2
-  // connection a drain sequence will occur prior to closing the connection. See
-  // :ref:`drain_timeout
-  // <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.drain_timeout>`.
-  google.protobuf.Duration idle_timeout = 11 [(gogoproto.stdduration) = true];
+  // connection a drain sequence will occur prior to closing the connection.
+  // This field is deprecated. Use :ref:`idle_timeout
+  // <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.common_http_protocol_options>`
+  // instead.
+  google.protobuf.Duration idle_timeout = 11 [(gogoproto.stdduration) = true, deprecated = true];
 
   // The stream idle timeout for connections managed by the connection manager.
   // If not specified, this defaults to 5 minutes. The default value was selected
diff --git a/docs/root/intro/version_history.rst b/docs/root/intro/version_history.rst
index a27b4118b..06b75dbd2 100644
--- a/docs/root/intro/version_history.rst
+++ b/docs/root/intro/version_history.rst
@@ -1,6 +1,13 @@
 Version history
 ---------------
 
+1.11.2 (October 8, 2019)
+============
+* http: added :ref:`max headers count <envoy_api_field_core.HttpProtocolOptions.max_headers_count>` for http connections. The default limit is 100.
+* upstream: runtime feature `envoy.reloadable_features.max_response_headers_count` overrides the default limit for upstream :ref:`max headers count <envoy_api_field_Cluster.common_http_protocol_options>`
+* http: added :ref:`common_http_protocol_options <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.common_http_protocol_options>`
+  Runtime feature `envoy.reloadable_features.max_request_headers_count` overrides the default limit for downstream :ref:`max headers count <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.common_http_protocol_options>`
+
 1.11.1 (August 13, 2019)
 ========================
 * http: added mitigation of client initiated attacks that result in flooding of the downstream HTTP/2 connections. Those attacks can be logged at the "warning" level when the runtime feature `http.connection_manager.log_flood_exception` is enabled. The runtime setting defaults to disabled to avoid log spam when under attack.
@@ -81,9 +88,7 @@ Version history
 * router: added a route name field to each http route in route.Route list
 * router: added several new variables for exposing information about the downstream TLS connection via :ref:`header
   formatters <config_http_conn_man_headers_custom_request_headers>`.
-* router: per try timeouts will no longer start before the downstream request has been received
-  in full by the router. This ensures that the per try timeout does not account for slow
-  downstreams and that will not start before the global timeout.
+* router: per try timeouts will no longer start before the downstream request has been received in full by the router.This ensures that the per try timeout does not account for slow downstreams and that will not start before the global timeout.
 * router: added :ref:`RouteAction's auto_host_rewrite_header <envoy_api_field_route.RouteAction.auto_host_rewrite_header>` to allow upstream host header substitution with some other header's value
 * router: added support for UPSTREAM_REMOTE_ADDRESS :ref:`header formatter
   <config_http_conn_man_headers_custom_request_headers>`.
diff --git a/include/envoy/http/codec.h b/include/envoy/http/codec.h
index eb5951d3b..cc0096074 100644
--- a/include/envoy/http/codec.h
+++ b/include/envoy/http/codec.h
@@ -15,6 +15,13 @@ namespace Http {
 
 // Legacy default value of 60K is safely under both codec default limits.
 static const uint32_t DEFAULT_MAX_REQUEST_HEADERS_KB = 60;
+// Default maximum number of headers.
+static const uint32_t DEFAULT_MAX_HEADERS_COUNT = 100;
+
+const char MaxRequestHeadersCountOverrideKey[] =
+    "envoy.reloadable_features.max_request_headers_count";
+const char MaxResponseHeadersCountOverrideKey[] =
+    "envoy.reloadable_features.max_response_headers_count";
 
 class Stream;
 
diff --git a/include/envoy/upstream/upstream.h b/include/envoy/upstream/upstream.h
index 567466c18..d72b56571 100644
--- a/include/envoy/upstream/upstream.h
+++ b/include/envoy/upstream/upstream.h
@@ -764,6 +764,12 @@ public:
    */
   virtual uint64_t maxRequestsPerConnection() const PURE;
 
+  /**
+   * @return uint32_t the maximum number of response headers. The default value is 100. Results in a
+   * reset if the number of headers exceeds this value.
+   */
+  virtual uint32_t maxResponseHeadersCount() const PURE;
+
   /**
    * @return the human readable name of the cluster.
    */
diff --git a/source/common/http/codec_client.cc b/source/common/http/codec_client.cc
index 6c5488ef7..2266c5984 100644
--- a/source/common/http/codec_client.cc
+++ b/source/common/http/codec_client.cc
@@ -140,13 +140,14 @@ CodecClientProd::CodecClientProd(Type type, Network::ClientConnectionPtr&& conne
     : CodecClient(type, std::move(connection), host, dispatcher) {
   switch (type) {
   case Type::HTTP1: {
-    codec_ = std::make_unique<Http1::ClientConnectionImpl>(*connection_, *this);
+    codec_ = std::make_unique<Http1::ClientConnectionImpl>(
+        *connection_, *this, host->cluster().maxResponseHeadersCount());
     break;
   }
   case Type::HTTP2: {
     codec_ = std::make_unique<Http2::ClientConnectionImpl>(
         *connection_, *this, host->cluster().statsScope(), host->cluster().http2Settings(),
-        Http::DEFAULT_MAX_REQUEST_HEADERS_KB);
+        Http::DEFAULT_MAX_REQUEST_HEADERS_KB, host->cluster().maxResponseHeadersCount());
     break;
   }
   }
diff --git a/source/common/http/conn_manager_config.h b/source/common/http/conn_manager_config.h
index 5e08e267d..da7fc02fb 100644
--- a/source/common/http/conn_manager_config.h
+++ b/source/common/http/conn_manager_config.h
@@ -228,6 +228,11 @@ public:
    */
   virtual uint32_t maxRequestHeadersKb() const PURE;
 
+  /**
+   * @return maximum number of request headers the codecs will accept.
+   */
+  virtual uint32_t maxRequestHeadersCount() const PURE;
+
   /**
    * @return per-stream idle timeout for incoming connection manager connections. Zero indicates a
    *         disabled idle timeout.
diff --git a/source/common/http/conn_manager_utility.cc b/source/common/http/conn_manager_utility.cc
index acc258499..bc8c84a12 100644
--- a/source/common/http/conn_manager_utility.cc
+++ b/source/common/http/conn_manager_utility.cc
@@ -41,13 +41,15 @@ std::string ConnectionManagerUtility::determineNextProtocol(Network::Connection&
 ServerConnectionPtr ConnectionManagerUtility::autoCreateCodec(
     Network::Connection& connection, const Buffer::Instance& data,
     ServerConnectionCallbacks& callbacks, Stats::Scope& scope, const Http1Settings& http1_settings,
-    const Http2Settings& http2_settings, const uint32_t max_request_headers_kb) {
+    const Http2Settings& http2_settings, const uint32_t max_request_headers_kb,
+    const uint32_t max_request_headers_count) {
   if (determineNextProtocol(connection, data) == Http2::ALPN_STRING) {
     return std::make_unique<Http2::ServerConnectionImpl>(connection, callbacks, scope,
-                                                         http2_settings, max_request_headers_kb);
+                                                         http2_settings, max_request_headers_kb,
+                                                         max_request_headers_count);
   } else {
-    return std::make_unique<Http1::ServerConnectionImpl>(connection, callbacks, http1_settings,
-                                                         max_request_headers_kb);
+    return std::make_unique<Http1::ServerConnectionImpl>(
+        connection, callbacks, http1_settings, max_request_headers_kb, max_request_headers_count);
   }
 }
 
diff --git a/source/common/http/conn_manager_utility.h b/source/common/http/conn_manager_utility.h
index 802d0ef07..ee67111c8 100644
--- a/source/common/http/conn_manager_utility.h
+++ b/source/common/http/conn_manager_utility.h
@@ -37,7 +37,7 @@ public:
   autoCreateCodec(Network::Connection& connection, const Buffer::Instance& data,
                   ServerConnectionCallbacks& callbacks, Stats::Scope& scope,
                   const Http1Settings& http1_settings, const Http2Settings& http2_settings,
-                  const uint32_t max_request_headers_kb);
+                  uint32_t max_request_headers_kb, uint32_t max_request_headers_count);
 
   /**
    * Mutates request headers in various ways. This functionality is broken out because of its
diff --git a/source/common/http/http1/codec_impl.cc b/source/common/http/http1/codec_impl.cc
index d03143a8e..0409f24fc 100644
--- a/source/common/http/http1/codec_impl.cc
+++ b/source/common/http/http1/codec_impl.cc
@@ -320,10 +320,10 @@ const ToLowerTable& ConnectionImpl::toLowerTable() {
 }
 
 ConnectionImpl::ConnectionImpl(Network::Connection& connection, http_parser_type type,
-                               uint32_t max_headers_kb)
+                               uint32_t max_headers_kb, const uint32_t max_headers_count)
     : connection_(connection), output_buffer_([&]() -> void { this->onBelowLowWatermark(); },
                                               [&]() -> void { this->onAboveHighWatermark(); }),
-      max_headers_kb_(max_headers_kb) {
+      max_headers_kb_(max_headers_kb), max_headers_count_(max_headers_count) {
   output_buffer_.setWatermarks(connection.bufferLimit());
   http_parser_init(&parser_, type);
   parser_.data = this;
@@ -337,6 +337,12 @@ void ConnectionImpl::completeLastHeader() {
     current_header_map_->addViaMove(std::move(current_header_field_),
                                     std::move(current_header_value_));
   }
+  // Check if the number of headers exceeds the limit.
+  if (current_header_map_->size() > max_headers_count_) {
+    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;
+    sendProtocolError();
+    throw CodecProtocolException("headers size exceeds limit");
+  }
 
   header_parsing_state_ = HeaderParsingState::Field;
   ASSERT(current_header_field_.empty());
@@ -501,9 +507,10 @@ void ConnectionImpl::onResetStreamBase(StreamResetReason reason) {
 
 ServerConnectionImpl::ServerConnectionImpl(Network::Connection& connection,
                                            ServerConnectionCallbacks& callbacks,
-                                           Http1Settings settings, uint32_t max_request_headers_kb)
-    : ConnectionImpl(connection, HTTP_REQUEST, max_request_headers_kb), callbacks_(callbacks),
-      codec_settings_(settings) {}
+                                           Http1Settings settings, uint32_t max_request_headers_kb,
+                                           const uint32_t max_request_headers_count)
+    : ConnectionImpl(connection, HTTP_REQUEST, max_request_headers_kb, max_request_headers_count),
+      callbacks_(callbacks), codec_settings_(settings) {}
 
 void ServerConnectionImpl::onEncodeComplete() {
   ASSERT(active_request_);
@@ -674,8 +681,10 @@ void ServerConnectionImpl::onBelowLowWatermark() {
   }
 }
 
-ClientConnectionImpl::ClientConnectionImpl(Network::Connection& connection, ConnectionCallbacks&)
-    : ConnectionImpl(connection, HTTP_RESPONSE, MAX_RESPONSE_HEADERS_KB) {}
+ClientConnectionImpl::ClientConnectionImpl(Network::Connection& connection, ConnectionCallbacks&,
+                                           const uint32_t max_response_headers_count)
+    : ConnectionImpl(connection, HTTP_RESPONSE, MAX_RESPONSE_HEADERS_KB,
+                     max_response_headers_count) {}
 
 bool ClientConnectionImpl::cannotHaveBody() {
   if ((!pending_responses_.empty() && pending_responses_.front().head_request_) ||
diff --git a/source/common/http/http1/codec_impl.h b/source/common/http/http1/codec_impl.h
index 27b80e5e5..c5de757c9 100644
--- a/source/common/http/http1/codec_impl.h
+++ b/source/common/http/http1/codec_impl.h
@@ -172,8 +172,8 @@ public:
   bool maybeDirectDispatch(Buffer::Instance& data);
 
 protected:
-  ConnectionImpl(Network::Connection& connection, http_parser_type type,
-                 uint32_t max_request_headers_kb);
+  ConnectionImpl(Network::Connection& connection, http_parser_type type, uint32_t max_headers_kb,
+                 const uint32_t max_headers_count);
 
   bool resetStreamCalled() { return reset_stream_called_; }
 
@@ -282,6 +282,7 @@ private:
   char* reserved_current_{};
   Protocol protocol_{Protocol::Http11};
   const uint32_t max_headers_kb_;
+  const uint32_t max_headers_count_;
 };
 
 /**
@@ -290,7 +291,8 @@ private:
 class ServerConnectionImpl : public ServerConnection, public ConnectionImpl {
 public:
   ServerConnectionImpl(Network::Connection& connection, ServerConnectionCallbacks& callbacks,
-                       Http1Settings settings, uint32_t max_request_headers_kb);
+                       Http1Settings settings, uint32_t max_request_headers_kb,
+                       const uint32_t max_request_headers_count);
 
   virtual bool supports_http_10() override { return codec_settings_.accept_http_10_; }
 
@@ -340,7 +342,8 @@ private:
  */
 class ClientConnectionImpl : public ClientConnection, public ConnectionImpl {
 public:
-  ClientConnectionImpl(Network::Connection& connection, ConnectionCallbacks& callbacks);
+  ClientConnectionImpl(Network::Connection& connection, ConnectionCallbacks& callbacks,
+                       const uint32_t max_response_headers_count);
 
   // Http::ClientConnection
   StreamEncoder& newStream(StreamDecoder& response_decoder) override;
diff --git a/source/common/http/http2/codec_impl.cc b/source/common/http/http2/codec_impl.cc
index 7564a661a..b914f7abb 100644
--- a/source/common/http/http2/codec_impl.cc
+++ b/source/common/http/http2/codec_impl.cc
@@ -370,10 +370,10 @@ bool checkRuntimeOverride(bool config_value, const char* override_key) {
 } // namespace
 
 ConnectionImpl::ConnectionImpl(Network::Connection& connection, Stats::Scope& stats,
-                               const Http2Settings& http2_settings,
-                               const uint32_t max_request_headers_kb)
+                               const Http2Settings& http2_settings, const uint32_t max_headers_kb,
+                               const uint32_t max_headers_count)
     : stats_{ALL_HTTP2_CODEC_STATS(POOL_COUNTER_PREFIX(stats, "http2."))}, connection_(connection),
-      max_request_headers_kb_(max_request_headers_kb),
+      max_headers_kb_(max_headers_kb), max_headers_count_(max_headers_count),
       per_stream_buffer_limit_(http2_settings.initial_stream_window_size_),
       stream_error_on_invalid_http_messaging_(checkRuntimeOverride(
           http2_settings.stream_error_on_invalid_http_messaging_, InvalidHttpMessagingOverrideKey)),
@@ -821,7 +821,8 @@ int ConnectionImpl::saveHeader(const nghttp2_frame* frame, HeaderString&& name,
   stream->saveHeader(std::move(name), std::move(value));
   // Verify that the cached value in byte size exists.
   ASSERT(stream->headers_->byteSize().has_value());
-  if (stream->headers_->byteSize().value() > max_request_headers_kb_ * 1024) {
+  if (stream->headers_->byteSize().value() > max_headers_kb_ * 1024 ||
+      stream->headers_->size() > max_headers_count_) {
     // This will cause the library to reset/close the stream.
     stats_.header_overflow_.inc();
     return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
@@ -1081,8 +1082,10 @@ ConnectionImpl::ClientHttp2Options::ClientHttp2Options(const Http2Settings& http
 ClientConnectionImpl::ClientConnectionImpl(Network::Connection& connection,
                                            Http::ConnectionCallbacks& callbacks,
                                            Stats::Scope& stats, const Http2Settings& http2_settings,
-                                           const uint32_t max_request_headers_kb)
-    : ConnectionImpl(connection, stats, http2_settings, max_request_headers_kb),
+                                           const uint32_t max_response_headers_kb,
+                                           const uint32_t max_response_headers_count)
+    : ConnectionImpl(connection, stats, http2_settings, max_response_headers_kb,
+                     max_response_headers_count),
       callbacks_(callbacks) {
   ClientHttp2Options client_http2_options(http2_settings);
   nghttp2_session_client_new2(&session_, http2_callbacks_.callbacks(), base(),
@@ -1130,8 +1133,10 @@ int ClientConnectionImpl::onHeader(const nghttp2_frame* frame, HeaderString&& na
 ServerConnectionImpl::ServerConnectionImpl(Network::Connection& connection,
                                            Http::ServerConnectionCallbacks& callbacks,
                                            Stats::Scope& scope, const Http2Settings& http2_settings,
-                                           const uint32_t max_request_headers_kb)
-    : ConnectionImpl(connection, scope, http2_settings, max_request_headers_kb),
+                                           const uint32_t max_request_headers_kb,
+                                           const uint32_t max_request_headers_count)
+    : ConnectionImpl(connection, scope, http2_settings, max_request_headers_kb,
+                     max_request_headers_count),
       callbacks_(callbacks) {
   Http2Options http2_options(http2_settings);
   nghttp2_session_server_new2(&session_, http2_callbacks_.callbacks(), base(),
diff --git a/source/common/http/http2/codec_impl.h b/source/common/http/http2/codec_impl.h
index 8c1760f9f..43fa59203 100644
--- a/source/common/http/http2/codec_impl.h
+++ b/source/common/http/http2/codec_impl.h
@@ -79,7 +79,8 @@ public:
 class ConnectionImpl : public virtual Connection, protected Logger::Loggable<Logger::Id::http2> {
 public:
   ConnectionImpl(Network::Connection& connection, Stats::Scope& stats,
-                 const Http2Settings& http2_settings, const uint32_t max_request_headers_kb);
+                 const Http2Settings& http2_settings, const uint32_t max_headers_kb,
+                 const uint32_t max_headers_count);
 
   ~ConnectionImpl();
 
@@ -288,7 +289,8 @@ protected:
   nghttp2_session* session_{};
   CodecStats stats_;
   Network::Connection& connection_;
-  const uint32_t max_request_headers_kb_;
+  const uint32_t max_headers_kb_;
+  const uint32_t max_headers_count_;
   uint32_t per_stream_buffer_limit_;
   bool allow_metadata_;
   const bool stream_error_on_invalid_http_messaging_;
@@ -394,7 +396,8 @@ class ClientConnectionImpl : public ClientConnection, public ConnectionImpl {
 public:
   ClientConnectionImpl(Network::Connection& connection, ConnectionCallbacks& callbacks,
                        Stats::Scope& stats, const Http2Settings& http2_settings,
-                       const uint32_t max_request_headers_kb);
+                       const uint32_t max_response_headers_kb,
+                       const uint32_t max_response_headers_count);
 
   // Http::ClientConnection
   Http::StreamEncoder& newStream(StreamDecoder& response_decoder) override;
@@ -426,7 +429,8 @@ class ServerConnectionImpl : public ServerConnection, public ConnectionImpl {
 public:
   ServerConnectionImpl(Network::Connection& connection, ServerConnectionCallbacks& callbacks,
                        Stats::Scope& scope, const Http2Settings& http2_settings,
-                       const uint32_t max_request_headers_kb);
+                       const uint32_t max_request_headers_kb,
+                       const uint32_t max_request_headers_count);
 
 private:
   // ConnectionImpl
diff --git a/source/common/upstream/BUILD b/source/common/upstream/BUILD
index 5177da76d..32b47dad5 100644
--- a/source/common/upstream/BUILD
+++ b/source/common/upstream/BUILD
@@ -389,6 +389,7 @@ envoy_cc_library(
         "//source/common/network:utility_lib",
         "//source/common/protobuf",
         "//source/common/protobuf:utility_lib",
+        "//source/common/runtime:runtime_lib",
         "//source/extensions/transport_sockets:well_known_names",
         "//source/server:transport_socket_config_lib",
         "@envoy_api//envoy/api/v2/core:base_cc",
diff --git a/source/common/upstream/upstream_impl.cc b/source/common/upstream/upstream_impl.cc
index 03ca1318c..6886b72e2 100644
--- a/source/common/upstream/upstream_impl.cc
+++ b/source/common/upstream/upstream_impl.cc
@@ -31,6 +31,7 @@
 #include "common/network/socket_option_factory.h"
 #include "common/protobuf/protobuf.h"
 #include "common/protobuf/utility.h"
+#include "common/runtime/runtime_impl.h"
 #include "common/upstream/eds.h"
 #include "common/upstream/health_checker_impl.h"
 #include "common/upstream/logical_dns_cluster.h"
@@ -552,6 +553,10 @@ ClusterInfoImpl::ClusterInfoImpl(const envoy::api::v2::Cluster& config,
     : runtime_(runtime), name_(config.name()), type_(config.type()),
       max_requests_per_connection_(
           PROTOBUF_GET_WRAPPED_OR_DEFAULT(config, max_requests_per_connection, 0)),
+      max_response_headers_count_(PROTOBUF_GET_WRAPPED_OR_DEFAULT(
+          config.common_http_protocol_options(), max_headers_count,
+          runtime_.snapshot().getInteger(Http::MaxResponseHeadersCountOverrideKey,
+                                         Http::DEFAULT_MAX_HEADERS_COUNT))),
       connect_timeout_(
           std::chrono::milliseconds(PROTOBUF_GET_MS_REQUIRED(config, connect_timeout))),
       per_connection_buffer_limit_bytes_(
@@ -628,6 +633,7 @@ ClusterInfoImpl::ClusterInfoImpl(const envoy::api::v2::Cluster& config,
     idle_timeout_ = std::chrono::milliseconds(
         DurationUtil::durationToMilliseconds(config.common_http_protocol_options().idle_timeout()));
   }
+
   if (config.has_eds_cluster_config()) {
     if (config.type() != envoy::api::v2::Cluster::EDS) {
       throw EnvoyException("eds_cluster_config set in a non-EDS cluster");
diff --git a/source/common/upstream/upstream_impl.h b/source/common/upstream/upstream_impl.h
index 5d07e9a16..fd37f9461 100644
--- a/source/common/upstream/upstream_impl.h
+++ b/source/common/upstream/upstream_impl.h
@@ -552,6 +552,7 @@ public:
   }
   bool maintenanceMode() const override;
   uint64_t maxRequestsPerConnection() const override { return max_requests_per_connection_; }
+  uint32_t maxResponseHeadersCount() const override { return max_response_headers_count_; }
   const std::string& name() const override { return name_; }
   ResourceManager& resourceManager(ResourcePriority priority) const override;
   Network::TransportSocketFactory& transportSocketFactory() const override {
@@ -593,6 +594,7 @@ private:
   const std::string name_;
   const envoy::api::v2::Cluster::DiscoveryType type_;
   const uint64_t max_requests_per_connection_;
+  const uint32_t max_response_headers_count_;
   const std::chrono::milliseconds connect_timeout_;
   absl::optional<std::chrono::milliseconds> idle_timeout_;
   const uint32_t per_connection_buffer_limit_bytes_;
diff --git a/source/extensions/filters/network/http_connection_manager/BUILD b/source/extensions/filters/network/http_connection_manager/BUILD
index 1f5474a65..6f1c4ce09 100644
--- a/source/extensions/filters/network/http_connection_manager/BUILD
+++ b/source/extensions/filters/network/http_connection_manager/BUILD
@@ -38,6 +38,7 @@ envoy_cc_library(
         "//source/common/protobuf:utility_lib",
         "//source/common/router:rds_lib",
         "//source/common/router:scoped_rds_lib",
+        "//source/common/runtime:runtime_lib",
         "//source/extensions/filters/network:well_known_names",
         "//source/extensions/filters/network/common:factory_base_lib",
     ],
diff --git a/source/extensions/filters/network/http_connection_manager/config.cc b/source/extensions/filters/network/http_connection_manager/config.cc
index 04edfdba7..8bc2316ae 100644
--- a/source/extensions/filters/network/http_connection_manager/config.cc
+++ b/source/extensions/filters/network/http_connection_manager/config.cc
@@ -23,6 +23,7 @@
 #include "common/protobuf/utility.h"
 #include "common/router/rds_impl.h"
 #include "common/router/scoped_rds.h"
+#include "common/runtime/runtime_impl.h"
 
 namespace Envoy {
 namespace Extensions {
@@ -149,7 +150,11 @@ HttpConnectionManagerConfig::HttpConnectionManagerConfig(
       http1_settings_(Http::Utility::parseHttp1Settings(config.http_protocol_options())),
       max_request_headers_kb_(PROTOBUF_GET_WRAPPED_OR_DEFAULT(
           config, max_request_headers_kb, Http::DEFAULT_MAX_REQUEST_HEADERS_KB)),
-      idle_timeout_(PROTOBUF_GET_OPTIONAL_MS(config, idle_timeout)),
+      max_request_headers_count_(PROTOBUF_GET_WRAPPED_OR_DEFAULT(
+          config.common_http_protocol_options(), max_headers_count,
+          context.runtime().snapshot().getInteger(Http::MaxRequestHeadersCountOverrideKey,
+                                                  Http::DEFAULT_MAX_HEADERS_COUNT))),
+      idle_timeout_(PROTOBUF_GET_OPTIONAL_MS(config.common_http_protocol_options(), idle_timeout)),
       stream_idle_timeout_(
           PROTOBUF_GET_MS_OR_DEFAULT(config, stream_idle_timeout, StreamIdleTimeoutMs)),
       request_timeout_(PROTOBUF_GET_MS_OR_DEFAULT(config, request_timeout, RequestTimeoutMs)),
@@ -171,6 +176,12 @@ HttpConnectionManagerConfig::HttpConnectionManagerConfig(
                                                       0
 #endif
                                                       ))) {
+  // If idle_timeout_ was not configured in common_http_protocol_options, use value in deprecated
+  // idle_timeout field.
+  // TODO(asraa): Remove when idle_timeout is removed.
+  if (!idle_timeout_) {
+    idle_timeout_ = PROTOBUF_GET_OPTIONAL_MS(config, idle_timeout);
+  }
   // If scoped RDS is enabled, avoid creating a route config provider. Route config providers will
   // be managed by the scoped routing logic instead.
   switch (config.route_specifier_case()) {
@@ -367,14 +378,15 @@ HttpConnectionManagerConfig::createCodec(Network::Connection& connection,
   switch (codec_type_) {
   case CodecType::HTTP1:
     return std::make_unique<Http::Http1::ServerConnectionImpl>(
-        connection, callbacks, http1_settings_, maxRequestHeadersKb());
+        connection, callbacks, http1_settings_, maxRequestHeadersKb(), maxRequestHeadersCount());
   case CodecType::HTTP2:
     return std::make_unique<Http::Http2::ServerConnectionImpl>(
-        connection, callbacks, context_.scope(), http2_settings_, maxRequestHeadersKb());
+        connection, callbacks, context_.scope(), http2_settings_, maxRequestHeadersKb(),
+        maxRequestHeadersCount());
   case CodecType::AUTO:
-    return Http::ConnectionManagerUtility::autoCreateCodec(connection, data, callbacks,
-                                                           context_.scope(), http1_settings_,
-                                                           http2_settings_, maxRequestHeadersKb());
+    return Http::ConnectionManagerUtility::autoCreateCodec(
+        connection, data, callbacks, context_.scope(), http1_settings_, http2_settings_,
+        maxRequestHeadersKb(), maxRequestHeadersCount());
   }
 
   NOT_REACHED_GCOVR_EXCL_LINE;
diff --git a/source/extensions/filters/network/http_connection_manager/config.h b/source/extensions/filters/network/http_connection_manager/config.h
index 796b67fc9..157f89b34 100644
--- a/source/extensions/filters/network/http_connection_manager/config.h
+++ b/source/extensions/filters/network/http_connection_manager/config.h
@@ -106,6 +106,7 @@ public:
   bool generateRequestId() override { return generate_request_id_; }
   bool preserveExternalRequestId() const override { return preserve_external_request_id_; }
   uint32_t maxRequestHeadersKb() const override { return max_request_headers_kb_; }
+  uint32_t maxRequestHeadersCount() const override { return max_request_headers_count_; }
   absl::optional<std::chrono::milliseconds> idleTimeout() const override { return idle_timeout_; }
   std::chrono::milliseconds streamIdleTimeout() const override { return stream_idle_timeout_; }
   std::chrono::milliseconds requestTimeout() const override { return request_timeout_; }
@@ -169,6 +170,7 @@ private:
   Http::TracingConnectionManagerConfigPtr tracing_config_;
   absl::optional<std::string> user_agent_;
   const uint32_t max_request_headers_kb_;
+  const uint32_t max_request_headers_count_;
   absl::optional<std::chrono::milliseconds> idle_timeout_;
   std::chrono::milliseconds stream_idle_timeout_;
   std::chrono::milliseconds request_timeout_;
diff --git a/source/server/http/admin.cc b/source/server/http/admin.cc
index 336c8694e..91ce57cbd 100644
--- a/source/server/http/admin.cc
+++ b/source/server/http/admin.cc
@@ -1273,7 +1273,7 @@ Http::ServerConnectionPtr AdminImpl::createCodec(Network::Connection& connection
                                                  Http::ServerConnectionCallbacks& callbacks) {
   return Http::ConnectionManagerUtility::autoCreateCodec(
       connection, data, callbacks, server_.stats(), Http::Http1Settings(), Http::Http2Settings(),
-      maxRequestHeadersKb());
+      maxRequestHeadersKb(), maxRequestHeadersCount());
 }
 
 bool AdminImpl::createNetworkFilterChain(Network::Connection& connection,
diff --git a/source/server/http/admin.h b/source/server/http/admin.h
index 2991515cf..1d23b4455 100644
--- a/source/server/http/admin.h
+++ b/source/server/http/admin.h
@@ -112,6 +112,7 @@ public:
   bool preserveExternalRequestId() const override { return false; }
   absl::optional<std::chrono::milliseconds> idleTimeout() const override { return idle_timeout_; }
   uint32_t maxRequestHeadersKb() const override { return max_request_headers_kb_; }
+  uint32_t maxRequestHeadersCount() const override { return max_request_headers_count_; }
   std::chrono::milliseconds streamIdleTimeout() const override { return {}; }
   std::chrono::milliseconds requestTimeout() const override { return {}; }
   std::chrono::milliseconds delayedCloseTimeout() const override { return {}; }
@@ -358,6 +359,7 @@ private:
   NullScopedRouteConfigProvider scoped_route_config_provider_;
   std::list<UrlHandler> handlers_;
   const uint32_t max_request_headers_kb_{Http::DEFAULT_MAX_REQUEST_HEADERS_KB};
+  const uint32_t max_request_headers_count_{Http::DEFAULT_MAX_HEADERS_COUNT};
   absl::optional<std::chrono::milliseconds> idle_timeout_;
   absl::optional<std::string> user_agent_;
   Http::SlowDateProviderImpl date_provider_;
diff --git a/test/common/http/codec_impl_fuzz_test.cc b/test/common/http/codec_impl_fuzz_test.cc
index 7d51f3666..87e1248d8 100644
--- a/test/common/http/codec_impl_fuzz_test.cc
+++ b/test/common/http/codec_impl_fuzz_test.cc
@@ -350,29 +350,33 @@ void codecFuzz(const test::common::http::CodecImplFuzzTestCase& input, HttpVersi
   const Http2Settings client_http2settings{fromHttp2Settings(input.h2_settings().client())};
   NiceMock<MockConnectionCallbacks> client_callbacks;
   uint32_t max_request_headers_kb = Http::DEFAULT_MAX_REQUEST_HEADERS_KB;
+  uint32_t max_request_headers_count = Http::DEFAULT_MAX_HEADERS_COUNT;
+  uint32_t max_response_headers_count = Http::DEFAULT_MAX_HEADERS_COUNT;
   ClientConnectionPtr client;
   ServerConnectionPtr server;
   const bool http2 = http_version == HttpVersion::Http2;
 
   if (http2) {
-    client = std::make_unique<Http2::TestClientConnectionImpl>(client_connection, client_callbacks,
-                                                               stats_store, client_http2settings,
-                                                               max_request_headers_kb);
+    client = std::make_unique<Http2::TestClientConnectionImpl>(
+        client_connection, client_callbacks, stats_store, client_http2settings,
+        max_request_headers_kb, max_response_headers_count);
   } else {
-    client = std::make_unique<Http1::ClientConnectionImpl>(client_connection, client_callbacks);
+    client = std::make_unique<Http1::ClientConnectionImpl>(client_connection, client_callbacks,
+                                                           max_response_headers_count);
   }
 
   NiceMock<Network::MockConnection> server_connection;
   NiceMock<MockServerConnectionCallbacks> server_callbacks;
   if (http2) {
     const Http2Settings server_http2settings{fromHttp2Settings(input.h2_settings().server())};
-    server = std::make_unique<Http2::TestServerConnectionImpl>(server_connection, server_callbacks,
-                                                               stats_store, server_http2settings,
-                                                               max_request_headers_kb);
+    server = std::make_unique<Http2::TestServerConnectionImpl>(
+        server_connection, server_callbacks, stats_store, server_http2settings,
+        max_request_headers_kb, max_request_headers_count);
   } else {
     const Http1Settings server_http1settings{fromHttp1Settings(input.h1_settings().server())};
     server = std::make_unique<Http1::ServerConnectionImpl>(
-        server_connection, server_callbacks, server_http1settings, max_request_headers_kb);
+        server_connection, server_callbacks, server_http1settings, max_request_headers_kb,
+        max_request_headers_count);
   }
 
   ReorderBuffer client_write_buf{*server};
diff --git a/test/common/http/conn_manager_impl_fuzz_test.cc b/test/common/http/conn_manager_impl_fuzz_test.cc
index 3c11424b5..d029f963c 100644
--- a/test/common/http/conn_manager_impl_fuzz_test.cc
+++ b/test/common/http/conn_manager_impl_fuzz_test.cc
@@ -81,6 +81,7 @@ public:
   bool generateRequestId() override { return true; }
   bool preserveExternalRequestId() const override { return false; }
   uint32_t maxRequestHeadersKb() const override { return max_request_headers_kb_; }
+  uint32_t maxRequestHeadersCount() const override { return max_request_headers_count_; }
   absl::optional<std::chrono::milliseconds> idleTimeout() const override { return idle_timeout_; }
   std::chrono::milliseconds streamIdleTimeout() const override { return stream_idle_timeout_; }
   std::chrono::milliseconds requestTimeout() const override { return request_timeout_; }
@@ -127,6 +128,7 @@ public:
   ConnectionManagerTracingStats tracing_stats_;
   ConnectionManagerListenerStats listener_stats_;
   uint32_t max_request_headers_kb_{Http::DEFAULT_MAX_REQUEST_HEADERS_KB};
+  uint32_t max_request_headers_count_{Http::DEFAULT_MAX_HEADERS_COUNT};
   absl::optional<std::chrono::milliseconds> idle_timeout_;
   std::chrono::milliseconds stream_idle_timeout_{};
   std::chrono::milliseconds request_timeout_{};
diff --git a/test/common/http/conn_manager_impl_test.cc b/test/common/http/conn_manager_impl_test.cc
index 8293ec155..68859d4e7 100644
--- a/test/common/http/conn_manager_impl_test.cc
+++ b/test/common/http/conn_manager_impl_test.cc
@@ -252,6 +252,7 @@ public:
   bool generateRequestId() override { return true; }
   bool preserveExternalRequestId() const override { return false; }
   uint32_t maxRequestHeadersKb() const override { return max_request_headers_kb_; }
+  uint32_t maxRequestHeadersCount() const override { return max_request_headers_count_; }
   absl::optional<std::chrono::milliseconds> idleTimeout() const override { return idle_timeout_; }
   std::chrono::milliseconds streamIdleTimeout() const override { return stream_idle_timeout_; }
   std::chrono::milliseconds requestTimeout() const override { return request_timeout_; }
@@ -307,6 +308,7 @@ public:
   std::vector<Http::ClientCertDetailsType> set_current_client_cert_details_;
   absl::optional<std::string> user_agent_;
   uint32_t max_request_headers_kb_{Http::DEFAULT_MAX_REQUEST_HEADERS_KB};
+  uint32_t max_request_headers_count_{Http::DEFAULT_MAX_HEADERS_COUNT};
   absl::optional<std::chrono::milliseconds> idle_timeout_;
   std::chrono::milliseconds stream_idle_timeout_{};
   std::chrono::milliseconds request_timeout_{};
diff --git a/test/common/http/conn_manager_utility_test.cc b/test/common/http/conn_manager_utility_test.cc
index 46937cf17..12f2be0b4 100644
--- a/test/common/http/conn_manager_utility_test.cc
+++ b/test/common/http/conn_manager_utility_test.cc
@@ -56,6 +56,7 @@ public:
   MOCK_METHOD0(generateRequestId, bool());
   MOCK_CONST_METHOD0(preserveExternalRequestId, bool());
   MOCK_CONST_METHOD0(maxRequestHeadersKb, uint32_t());
+  MOCK_CONST_METHOD0(maxRequestHeadersCount, uint32_t());
   MOCK_CONST_METHOD0(idleTimeout, absl::optional<std::chrono::milliseconds>());
   MOCK_CONST_METHOD0(streamIdleTimeout, std::chrono::milliseconds());
   MOCK_CONST_METHOD0(requestTimeout, std::chrono::milliseconds());
diff --git a/test/common/http/http1/codec_impl_test.cc b/test/common/http/http1/codec_impl_test.cc
index c65d0ba18..39208c2e1 100644
--- a/test/common/http/http1/codec_impl_test.cc
+++ b/test/common/http/http1/codec_impl_test.cc
@@ -27,12 +27,23 @@ using testing::ReturnRef;
 namespace Envoy {
 namespace Http {
 namespace Http1 {
+namespace {
+std::string createHeaderFragment(int num_headers) {
+  // Create a header field with num_headers headers.
+  std::string headers;
+  for (int i = 0; i < num_headers; i++) {
+    headers += "header" + std::to_string(i) + ": " + "\r\n";
+  }
+  return headers;
+}
+} // namespace
 
 class Http1ServerConnectionImplTest : public testing::Test {
 public:
   void initialize() {
-    codec_ = std::make_unique<ServerConnectionImpl>(connection_, callbacks_, codec_settings_,
-                                                    max_request_headers_kb_);
+    codec_ =
+        std::make_unique<ServerConnectionImpl>(connection_, callbacks_, codec_settings_,
+                                               max_request_headers_kb_, max_request_headers_count_);
   }
 
   NiceMock<Network::MockConnection> connection_;
@@ -43,9 +54,12 @@ public:
   void expectHeadersTest(Protocol p, bool allow_absolute_url, Buffer::OwnedImpl& buffer,
                          TestHeaderMapImpl& expected_headers);
   void expect400(Protocol p, bool allow_absolute_url, Buffer::OwnedImpl& buffer);
+  void testRequestHeadersExceedLimit(std::string header_string);
+  void testRequestHeadersAccepted(std::string header_string);
 
 protected:
   uint32_t max_request_headers_kb_{Http::DEFAULT_MAX_REQUEST_HEADERS_KB};
+  uint32_t max_request_headers_count_{Http::DEFAULT_MAX_HEADERS_COUNT};
 };
 
 void Http1ServerConnectionImplTest::expect400(Protocol p, bool allow_absolute_url,
@@ -57,8 +71,9 @@ void Http1ServerConnectionImplTest::expect400(Protocol p, bool allow_absolute_ur
 
   if (allow_absolute_url) {
     codec_settings_.allow_absolute_url_ = allow_absolute_url;
-    codec_ = std::make_unique<ServerConnectionImpl>(connection_, callbacks_, codec_settings_,
-                                                    max_request_headers_kb_);
+    codec_ =
+        std::make_unique<ServerConnectionImpl>(connection_, callbacks_, codec_settings_,
+                                               max_request_headers_kb_, max_request_headers_count_);
   }
 
   Http::MockStreamDecoder decoder;
@@ -77,8 +92,9 @@ void Http1ServerConnectionImplTest::expectHeadersTest(Protocol p, bool allow_abs
   // Make a new 'codec' with the right settings
   if (allow_absolute_url) {
     codec_settings_.allow_absolute_url_ = allow_absolute_url;
-    codec_ = std::make_unique<ServerConnectionImpl>(connection_, callbacks_, codec_settings_,
-                                                    max_request_headers_kb_);
+    codec_ =
+        std::make_unique<ServerConnectionImpl>(connection_, callbacks_, codec_settings_,
+                                               max_request_headers_kb_, max_request_headers_count_);
   }
 
   Http::MockStreamDecoder decoder;
@@ -90,6 +106,41 @@ void Http1ServerConnectionImplTest::expectHeadersTest(Protocol p, bool allow_abs
   EXPECT_EQ(p, codec_->protocol());
 }
 
+void Http1ServerConnectionImplTest::testRequestHeadersExceedLimit(std::string header_string) {
+  initialize();
+
+  std::string exception_reason;
+  NiceMock<Http::MockStreamDecoder> decoder;
+  Http::StreamEncoder* response_encoder = nullptr;
+  EXPECT_CALL(callbacks_, newStream(_, _))
+      .WillOnce(Invoke([&](Http::StreamEncoder& encoder, bool) -> Http::StreamDecoder& {
+        response_encoder = &encoder;
+        return decoder;
+      }));
+
+  Buffer::OwnedImpl buffer("GET / HTTP/1.1\r\n");
+  codec_->dispatch(buffer);
+  buffer = Buffer::OwnedImpl(header_string + "\r\n");
+  EXPECT_THROW_WITH_MESSAGE(codec_->dispatch(buffer), EnvoyException, "headers size exceeds limit");
+}
+
+void Http1ServerConnectionImplTest::testRequestHeadersAccepted(std::string header_string) {
+  initialize();
+
+  NiceMock<Http::MockStreamDecoder> decoder;
+  Http::StreamEncoder* response_encoder = nullptr;
+  EXPECT_CALL(callbacks_, newStream(_, _))
+      .WillOnce(Invoke([&](Http::StreamEncoder& encoder, bool) -> Http::StreamDecoder& {
+        response_encoder = &encoder;
+        return decoder;
+      }));
+
+  Buffer::OwnedImpl buffer("GET / HTTP/1.1\r\n");
+  codec_->dispatch(buffer);
+  buffer = Buffer::OwnedImpl(header_string + "\r\n");
+  codec_->dispatch(buffer);
+}
+
 TEST_F(Http1ServerConnectionImplTest, EmptyHeader) {
   initialize();
 
@@ -784,11 +835,15 @@ TEST_F(Http1ServerConnectionImplTest, WatermarkTest) {
 
 class Http1ClientConnectionImplTest : public testing::Test {
 public:
-  void initialize() { codec_ = std::make_unique<ClientConnectionImpl>(connection_, callbacks_); }
+  void initialize() {
+    codec_ = std::make_unique<ClientConnectionImpl>(connection_, callbacks_,
+                                                    max_response_headers_count_);
+  }
 
   NiceMock<Network::MockConnection> connection_;
   NiceMock<Http::MockConnectionCallbacks> callbacks_;
   std::unique_ptr<ClientConnectionImpl> codec_;
+  uint32_t max_response_headers_count_{Http::DEFAULT_MAX_HEADERS_COUNT};
 };
 
 TEST_F(Http1ClientConnectionImplTest, SimpleGet) {
@@ -1129,27 +1184,19 @@ TEST_F(Http1ClientConnectionImplTest, HighwatermarkMultipleResponses) {
   static_cast<ClientConnection*>(codec_.get())
       ->onUnderlyingConnectionBelowWriteBufferLowWatermark();
 }
-TEST_F(Http1ServerConnectionImplTest, TestLargeRequestHeadersRejected) {
+TEST_F(Http1ServerConnectionImplTest, LargeRequestHeadersRejected) {
   // Default limit of 60 KiB
-  initialize();
-
-  std::string exception_reason;
-  NiceMock<Http::MockStreamDecoder> decoder;
-  Http::StreamEncoder* response_encoder = nullptr;
-  EXPECT_CALL(callbacks_, newStream(_, _))
-      .WillOnce(Invoke([&](Http::StreamEncoder& encoder, bool) -> Http::StreamDecoder& {
-        response_encoder = &encoder;
-        return decoder;
-      }));
-
-  Buffer::OwnedImpl buffer("GET / HTTP/1.1\r\n");
-  codec_->dispatch(buffer);
   std::string long_string = "big: " + std::string(60 * 1024, 'q') + "\r\n";
-  buffer = Buffer::OwnedImpl(long_string);
-  EXPECT_THROW_WITH_MESSAGE(codec_->dispatch(buffer), EnvoyException, "headers size exceeds limit");
+  testRequestHeadersExceedLimit(long_string);
+}
+
+// Tests that the default limit for the number of request headers is 100.
+TEST_F(Http1ServerConnectionImplTest, ManyRequestHeadersRejected) {
+  // Send a request with 101 headers.
+  testRequestHeadersExceedLimit(createHeaderFragment(101));
 }
 
-TEST_F(Http1ServerConnectionImplTest, TestLargeRequestHeadersSplitRejected) {
+TEST_F(Http1ServerConnectionImplTest, LargeRequestHeadersSplitRejected) {
   // Default limit of 60 KiB
   initialize();
 
@@ -1174,10 +1221,13 @@ TEST_F(Http1ServerConnectionImplTest, TestLargeRequestHeadersSplitRejected) {
   EXPECT_THROW_WITH_MESSAGE(codec_->dispatch(buffer), EnvoyException, "headers size exceeds limit");
 }
 
-TEST_F(Http1ServerConnectionImplTest, TestLargeRequestHeadersAccepted) {
-  max_request_headers_kb_ = 65;
+// Tests that the 101th request header causes overflow with the default max number of request
+// headers.
+TEST_F(Http1ServerConnectionImplTest, ManyRequestHeadersSplitRejected) {
+  // Default limit of 100.
   initialize();
 
+  std::string exception_reason;
   NiceMock<Http::MockStreamDecoder> decoder;
   Http::StreamEncoder* response_encoder = nullptr;
   EXPECT_CALL(callbacks_, newStream(_, _))
@@ -1185,34 +1235,39 @@ TEST_F(Http1ServerConnectionImplTest, TestLargeRequestHeadersAccepted) {
         response_encoder = &encoder;
         return decoder;
       }));
-
   Buffer::OwnedImpl buffer("GET / HTTP/1.1\r\n");
   codec_->dispatch(buffer);
-  std::string long_string = "big: " + std::string(64 * 1024, 'q') + "\r\n";
-  buffer = Buffer::OwnedImpl(long_string);
+
+  // Dispatch 100 headers.
+  buffer = Buffer::OwnedImpl(createHeaderFragment(100));
   codec_->dispatch(buffer);
-}
 
-TEST_F(Http1ServerConnectionImplTest, TestLargeRequestHeadersAcceptedMaxConfigurable) {
-  max_request_headers_kb_ = 96;
-  initialize();
+  // The final 101th header should induce overflow.
+  buffer = Buffer::OwnedImpl("header101:\r\n\r\n");
+  EXPECT_THROW_WITH_MESSAGE(codec_->dispatch(buffer), EnvoyException, "headers size exceeds limit");
+}
 
-  NiceMock<Http::MockStreamDecoder> decoder;
-  Http::StreamEncoder* response_encoder = nullptr;
-  EXPECT_CALL(callbacks_, newStream(_, _))
-      .WillOnce(Invoke([&](Http::StreamEncoder& encoder, bool) -> Http::StreamDecoder& {
-        response_encoder = &encoder;
-        return decoder;
-      }));
+TEST_F(Http1ServerConnectionImplTest, LargeRequestHeadersAccepted) {
+  max_request_headers_kb_ = 65;
+  std::string long_string = "big: " + std::string(64 * 1024, 'q') + "\r\n";
+  testRequestHeadersAccepted(long_string);
+}
 
-  Buffer::OwnedImpl buffer("GET / HTTP/1.1\r\n");
-  codec_->dispatch(buffer);
+TEST_F(Http1ServerConnectionImplTest, LargeRequestHeadersAcceptedMaxConfigurable) {
+  max_request_headers_kb_ = 96;
   std::string long_string = "big: " + std::string(95 * 1024, 'q') + "\r\n";
-  buffer = Buffer::OwnedImpl(long_string);
-  codec_->dispatch(buffer);
+  testRequestHeadersAccepted(long_string);
+}
+
+// Tests that the number of request headers is configurable.
+TEST_F(Http1ServerConnectionImplTest, ManyRequestHeadersAccepted) {
+  max_request_headers_count_ = 150;
+  // Create a request with 150 headers.
+  testRequestHeadersAccepted(createHeaderFragment(150));
 }
 
-TEST_F(Http1ClientConnectionImplTest, TestLargeResponseHeadersRejected) {
+// Tests that response headers of 80 kB fails.
+TEST_F(Http1ClientConnectionImplTest, LargeResponseHeadersRejected) {
   initialize();
 
   NiceMock<Http::MockStreamDecoder> response_decoder;
@@ -1227,7 +1282,8 @@ TEST_F(Http1ClientConnectionImplTest, TestLargeResponseHeadersRejected) {
   EXPECT_THROW_WITH_MESSAGE(codec_->dispatch(buffer), EnvoyException, "headers size exceeds limit");
 }
 
-TEST_F(Http1ClientConnectionImplTest, TestLargeResponseHeadersAccepted) {
+// Tests that the size of response headers for HTTP/1 must be under 80 kB.
+TEST_F(Http1ClientConnectionImplTest, LargeResponseHeadersAccepted) {
   initialize();
 
   NiceMock<Http::MockStreamDecoder> response_decoder;
@@ -1242,6 +1298,39 @@ TEST_F(Http1ClientConnectionImplTest, TestLargeResponseHeadersAccepted) {
   codec_->dispatch(buffer);
 }
 
+// Exception called when the number of response headers exceeds the default value of 100.
+TEST_F(Http1ClientConnectionImplTest, ManyResponseHeadersRejected) {
+  initialize();
+
+  NiceMock<Http::MockStreamDecoder> response_decoder;
+  Http::StreamEncoder& request_encoder = codec_->newStream(response_decoder);
+  TestHeaderMapImpl headers{{":method", "GET"}, {":path", "/"}, {":authority", "host"}};
+  request_encoder.encodeHeaders(headers, true);
+
+  Buffer::OwnedImpl buffer("HTTP/1.1 200 OK\r\nContent-Length: 0\r\n");
+  codec_->dispatch(buffer);
+  buffer = Buffer::OwnedImpl(createHeaderFragment(101) + "\r\n");
+  EXPECT_THROW_WITH_MESSAGE(codec_->dispatch(buffer), EnvoyException, "headers size exceeds limit");
+}
+
+// Tests that the number of response headers is configurable.
+TEST_F(Http1ClientConnectionImplTest, ManyResponseHeadersAccepted) {
+  max_response_headers_count_ = 152;
+
+  initialize();
+
+  NiceMock<Http::MockStreamDecoder> response_decoder;
+  Http::StreamEncoder& request_encoder = codec_->newStream(response_decoder);
+  TestHeaderMapImpl headers{{":method", "GET"}, {":path", "/"}, {":authority", "host"}};
+  request_encoder.encodeHeaders(headers, true);
+
+  Buffer::OwnedImpl buffer("HTTP/1.1 200 OK\r\nContent-Length: 0\r\n");
+  codec_->dispatch(buffer);
+  // Response already contains one header.
+  buffer = Buffer::OwnedImpl(createHeaderFragment(150) + "\r\n");
+  codec_->dispatch(buffer);
+}
+
 } // namespace Http1
 } // namespace Http
 } // namespace Envoy
diff --git a/test/common/http/http2/codec_impl_test.cc b/test/common/http/http2/codec_impl_test.cc
index 1393527fb..e406cb3ef 100644
--- a/test/common/http/http2/codec_impl_test.cc
+++ b/test/common/http/http2/codec_impl_test.cc
@@ -64,12 +64,12 @@ public:
   virtual void initialize() {
     Http2SettingsFromTuple(client_http2settings_, client_settings_);
     Http2SettingsFromTuple(server_http2settings_, server_settings_);
-    client_ = std::make_unique<TestClientConnectionImpl>(client_connection_, client_callbacks_,
-                                                         stats_store_, client_http2settings_,
-                                                         max_request_headers_kb_);
-    server_ = std::make_unique<TestServerConnectionImpl>(server_connection_, server_callbacks_,
-                                                         stats_store_, server_http2settings_,
-                                                         max_request_headers_kb_);
+    client_ = std::make_unique<TestClientConnectionImpl>(
+        client_connection_, client_callbacks_, stats_store_, client_http2settings_,
+        max_request_headers_kb_, max_response_headers_count_);
+    server_ = std::make_unique<TestServerConnectionImpl>(
+        server_connection_, server_callbacks_, stats_store_, server_http2settings_,
+        max_request_headers_kb_, max_request_headers_count_);
 
     request_encoder_ = &client_->newStream(response_decoder_);
     setupDefaultConnectionMocks();
@@ -155,6 +155,8 @@ public:
   bool corrupt_metadata_frame_ = false;
 
   uint32_t max_request_headers_kb_ = Http::DEFAULT_MAX_REQUEST_HEADERS_KB;
+  uint32_t max_request_headers_count_ = Http::DEFAULT_MAX_HEADERS_COUNT;
+  uint32_t max_response_headers_count_ = Http::DEFAULT_MAX_HEADERS_COUNT;
   uint32_t max_outbound_frames_ = Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES;
   uint32_t max_outbound_control_frames_ = Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES;
   uint32_t max_consecutive_inbound_frames_with_empty_payload_ =
@@ -964,12 +966,12 @@ class Http2CodecImplStreamLimitTest : public Http2CodecImplTest {};
 TEST_P(Http2CodecImplStreamLimitTest, MaxClientStreams) {
   Http2SettingsFromTuple(client_http2settings_, ::testing::get<0>(GetParam()));
   Http2SettingsFromTuple(server_http2settings_, ::testing::get<1>(GetParam()));
-  client_ = std::make_unique<TestClientConnectionImpl>(client_connection_, client_callbacks_,
-                                                       stats_store_, client_http2settings_,
-                                                       max_request_headers_kb_);
-  server_ = std::make_unique<TestServerConnectionImpl>(server_connection_, server_callbacks_,
-                                                       stats_store_, server_http2settings_,
-                                                       max_request_headers_kb_);
+  client_ = std::make_unique<TestClientConnectionImpl>(
+      client_connection_, client_callbacks_, stats_store_, client_http2settings_,
+      max_request_headers_kb_, max_response_headers_count_);
+  server_ = std::make_unique<TestServerConnectionImpl>(
+      server_connection_, server_callbacks_, stats_store_, server_http2settings_,
+      max_request_headers_kb_, max_request_headers_count_);
 
   for (int i = 0; i < 101; ++i) {
     request_encoder_ = &client_->newStream(response_decoder_);
@@ -1077,7 +1079,8 @@ TEST(Http2CodecUtility, reconstituteCrumbledCookies) {
   }
 }
 
-TEST_P(Http2CodecImplTest, TestLargeRequestHeadersInvokeResetStream) {
+// Tests request headers whose size is larger than the default limit of 60K.
+TEST_P(Http2CodecImplTest, LargeRequestHeadersInvokeResetStream) {
   initialize();
 
   TestHeaderMapImpl request_headers;
@@ -1088,7 +1091,8 @@ TEST_P(Http2CodecImplTest, TestLargeRequestHeadersInvokeResetStream) {
   request_encoder_->encodeHeaders(request_headers, false);
 }
 
-TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAccepted) {
+// Large request headers are accepted when max limit configured.
+TEST_P(Http2CodecImplTest, LargeRequestHeadersAccepted) {
   max_request_headers_kb_ = 64;
   initialize();
 
@@ -1102,7 +1106,53 @@ TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAccepted) {
   request_encoder_->encodeHeaders(request_headers, false);
 }
 
-TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {
+// Tests stream reset when the number of request headers exceeds the default maximum of 100.
+TEST_P(Http2CodecImplTest, ManyRequestHeadersInvokeResetStream) {
+  initialize();
+
+  TestHeaderMapImpl request_headers;
+  HttpTestUtility::addDefaultHeaders(request_headers);
+  for (int i = 0; i < 100; i++) {
+    request_headers.addCopy(std::to_string(i), "");
+  }
+  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(1);
+  request_encoder_->encodeHeaders(request_headers, false);
+}
+
+// Tests that max number of request headers is configurable.
+TEST_P(Http2CodecImplTest, ManyRequestHeadersAccepted) {
+  max_request_headers_count_ = 150;
+  initialize();
+
+  TestHeaderMapImpl request_headers;
+  HttpTestUtility::addDefaultHeaders(request_headers);
+  for (int i = 0; i < 145; i++) {
+    request_headers.addCopy(std::to_string(i), "");
+  }
+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));
+  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(0);
+  request_encoder_->encodeHeaders(request_headers, false);
+}
+
+// Tests that max number of response headers is configurable.
+TEST_P(Http2CodecImplTest, ManyResponseHeadersAccepted) {
+  max_response_headers_count_ = 110;
+  initialize();
+
+  TestHeaderMapImpl request_headers;
+  HttpTestUtility::addDefaultHeaders(request_headers);
+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
+  request_encoder_->encodeHeaders(request_headers, false);
+
+  TestHeaderMapImpl response_headers{{":status", "200"}, {"compression", "test"}};
+  for (int i = 0; i < 105; i++) {
+    response_headers.addCopy(std::to_string(i), "");
+  }
+  EXPECT_CALL(response_decoder_, decodeHeaders_(_, true));
+  response_encoder_->encodeHeaders(response_headers, true);
+}
+
+TEST_P(Http2CodecImplTest, LargeRequestHeadersAtLimitAccepted) {
   uint32_t codec_limit_kb = 64;
   max_request_headers_kb_ = codec_limit_kb;
   initialize();
@@ -1127,7 +1177,7 @@ TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {
   request_encoder_->encodeHeaders(request_headers, true);
 }
 
-TEST_P(Http2CodecImplTest, TestLargeRequestHeadersOverDefaultCodecLibraryLimit) {
+TEST_P(Http2CodecImplTest, LargeRequestHeadersOverDefaultCodecLibraryLimit) {
   max_request_headers_kb_ = 66;
   initialize();
 
@@ -1141,7 +1191,7 @@ TEST_P(Http2CodecImplTest, TestLargeRequestHeadersOverDefaultCodecLibraryLimit)
   request_encoder_->encodeHeaders(request_headers, true);
 }
 
-TEST_P(Http2CodecImplTest, TestLargeRequestHeadersExceedPerHeaderLimit) {
+TEST_P(Http2CodecImplTest, LargeRequestHeadersExceedPerHeaderLimit) {
   // The name-value pair max is set by NGHTTP2_HD_MAX_NV in lib/nghttp2_hd.h to 64KB, and
   // creates a per-request header limit for us in h2. Note that the nghttp2
   // calculated byte size will differ from envoy due to H2 compression and frames.
@@ -1161,7 +1211,7 @@ TEST_P(Http2CodecImplTest, TestLargeRequestHeadersExceedPerHeaderLimit) {
   request_encoder_->encodeHeaders(request_headers, true);
 }
 
-TEST_P(Http2CodecImplTest, TestManyLargeRequestHeadersUnderPerHeaderLimit) {
+TEST_P(Http2CodecImplTest, ManyLargeRequestHeadersUnderPerHeaderLimit) {
   max_request_headers_kb_ = 81;
   initialize();
 
@@ -1177,7 +1227,7 @@ TEST_P(Http2CodecImplTest, TestManyLargeRequestHeadersUnderPerHeaderLimit) {
   request_encoder_->encodeHeaders(request_headers, true);
 }
 
-TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtMaxConfigurable) {
+TEST_P(Http2CodecImplTest, LargeRequestHeadersAtMaxConfigurable) {
   // Raising the limit past this triggers some unexpected nghttp2 error.
   // Further debugging required to increase past ~96 KiB.
   max_request_headers_kb_ = 96;
diff --git a/test/common/http/http2/codec_impl_test_util.h b/test/common/http/http2/codec_impl_test_util.h
index 2c4652ee0..67521db0f 100644
--- a/test/common/http/http2/codec_impl_test_util.h
+++ b/test/common/http/http2/codec_impl_test_util.h
@@ -10,9 +10,9 @@ class TestServerConnectionImpl : public ServerConnectionImpl {
 public:
   TestServerConnectionImpl(Network::Connection& connection, ServerConnectionCallbacks& callbacks,
                            Stats::Scope& scope, const Http2Settings& http2_settings,
-                           uint32_t max_request_headers_kb)
-      : ServerConnectionImpl(connection, callbacks, scope, http2_settings, max_request_headers_kb) {
-  }
+                           uint32_t max_request_headers_kb, uint32_t max_request_headers_count)
+      : ServerConnectionImpl(connection, callbacks, scope, http2_settings, max_request_headers_kb,
+                             max_request_headers_count) {}
   nghttp2_session* session() { return session_; }
   using ServerConnectionImpl::getStream;
 };
@@ -21,9 +21,9 @@ class TestClientConnectionImpl : public ClientConnectionImpl {
 public:
   TestClientConnectionImpl(Network::Connection& connection, Http::ConnectionCallbacks& callbacks,
                            Stats::Scope& scope, const Http2Settings& http2_settings,
-                           uint32_t max_request_headers_kb)
-      : ClientConnectionImpl(connection, callbacks, scope, http2_settings, max_request_headers_kb) {
-  }
+                           uint32_t max_request_headers_kb, uint32_t max_request_headers_count)
+      : ClientConnectionImpl(connection, callbacks, scope, http2_settings, max_request_headers_kb,
+                             max_request_headers_count) {}
   nghttp2_session* session() { return session_; }
   using ClientConnectionImpl::getStream;
   using ConnectionImpl::sendPendingFrames;
diff --git a/test/common/http/http2/frame_replay.cc b/test/common/http/http2/frame_replay.cc
index 7d2fe1cc7..9bb172240 100644
--- a/test/common/http/http2/frame_replay.cc
+++ b/test/common/http/http2/frame_replay.cc
@@ -67,9 +67,9 @@ CodecFrameInjector::CodecFrameInjector(const std::string& injector_name)
 }
 
 ClientCodecFrameInjector::ClientCodecFrameInjector() : CodecFrameInjector("server") {
-  auto client = std::make_unique<TestClientConnectionImpl>(client_connection_, client_callbacks_,
-                                                           stats_store_, settings_,
-                                                           Http::DEFAULT_MAX_REQUEST_HEADERS_KB);
+  auto client = std::make_unique<TestClientConnectionImpl>(
+      client_connection_, client_callbacks_, stats_store_, settings_,
+      Http::DEFAULT_MAX_REQUEST_HEADERS_KB, Http::DEFAULT_MAX_HEADERS_COUNT);
   request_encoder_ = &client->newStream(response_decoder_);
   connection_ = std::move(client);
   ON_CALL(client_connection_, write(_, _))
@@ -87,9 +87,9 @@ ClientCodecFrameInjector::ClientCodecFrameInjector() : CodecFrameInjector("serve
 }
 
 ServerCodecFrameInjector::ServerCodecFrameInjector() : CodecFrameInjector("client") {
-  connection_ = std::make_unique<TestServerConnectionImpl>(server_connection_, server_callbacks_,
-                                                           stats_store_, settings_,
-                                                           Http::DEFAULT_MAX_REQUEST_HEADERS_KB);
+  connection_ = std::make_unique<TestServerConnectionImpl>(
+      server_connection_, server_callbacks_, stats_store_, settings_,
+      Http::DEFAULT_MAX_REQUEST_HEADERS_KB, Http::DEFAULT_MAX_HEADERS_COUNT);
   EXPECT_CALL(server_callbacks_, newStream(_, _))
       .WillRepeatedly(Invoke([&](StreamEncoder& encoder, bool) -> StreamDecoder& {
         encoder.getStream().addCallbacks(server_stream_callbacks_);
diff --git a/test/extensions/filters/network/http_connection_manager/config_test.cc b/test/extensions/filters/network/http_connection_manager/config_test.cc
index c232ad8fd..6dc483372 100644
--- a/test/extensions/filters/network/http_connection_manager/config_test.cc
+++ b/test/extensions/filters/network/http_connection_manager/config_test.cc
@@ -258,6 +258,75 @@ TEST_F(HttpConnectionManagerConfigTest, DisabledStreamIdleTimeout) {
   EXPECT_EQ(0, config.streamIdleTimeout().count());
 }
 
+// Validate that deprecated idle_timeout is still ingested.
+TEST_F(HttpConnectionManagerConfigTest, DeprecatedIdleTimeout) {
+  const std::string yaml_string = R"EOF(
+  stat_prefix: ingress_http
+  idle_timeout: 1s
+  route_config:
+    name: local_route
+  http_filters:
+  - name: envoy.router
+  )EOF";
+
+  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
+                                     date_provider_, route_config_provider_manager_,
+                                     scoped_routes_config_provider_manager_);
+  EXPECT_EQ(1000, config.idleTimeout().value().count());
+}
+
+// Validate that idle_timeout set in common_http_protocol_options is used.
+TEST_F(HttpConnectionManagerConfigTest, CommonHttpProtocolIdleTimeout) {
+  const std::string yaml_string = R"EOF(
+  stat_prefix: ingress_http
+  common_http_protocol_options:
+    idle_timeout: 1s
+  route_config:
+    name: local_route
+  http_filters:
+  - name: envoy.router
+  )EOF";
+
+  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
+                                     date_provider_, route_config_provider_manager_,
+                                     scoped_routes_config_provider_manager_);
+  EXPECT_EQ(1000, config.idleTimeout().value().count());
+}
+
+// Check that the default max request header count is 100.
+TEST_F(HttpConnectionManagerConfigTest, DefaultMaxRequestHeaderCount) {
+  const std::string yaml_string = R"EOF(
+  stat_prefix: ingress_http
+  route_config:
+    name: local_route
+  http_filters:
+  - name: envoy.router
+  )EOF";
+
+  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
+                                     date_provider_, route_config_provider_manager_,
+                                     scoped_routes_config_provider_manager_);
+  EXPECT_EQ(100, config.maxRequestHeadersCount());
+}
+
+// Check that max request header count is configured.
+TEST_F(HttpConnectionManagerConfigTest, MaxRequestHeaderCountConfigurable) {
+  const std::string yaml_string = R"EOF(
+  stat_prefix: ingress_http
+  common_http_protocol_options:
+    max_headers_count: 200
+  route_config:
+    name: local_route
+  http_filters:
+  - name: envoy.router
+  )EOF";
+
+  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
+                                     date_provider_, route_config_provider_manager_,
+                                     scoped_routes_config_provider_manager_);
+  EXPECT_EQ(200, config.maxRequestHeadersCount());
+}
+
 // Validated that by default we don't normalize paths
 // unless set build flag path_normalization_by_default=true
 TEST_F(HttpConnectionManagerConfigTest, NormalizePathDefault) {
diff --git a/test/integration/#http_integration.cc# b/test/integration/#http_integration.cc#
new file mode 100644
index 000000000..00f7e2e22
--- /dev/null
+++ b/test/integration/#http_integration.cc#
@@ -0,0 +1,1048 @@
+#include "test/integration/http_integration.h"
+
+#include <functional>
+#include <list>
+#include <memory>
+#include <regex>
+#include <string>
+#include <vector>
+
+#include "envoy/buffer/buffer.h"
+#include "envoy/event/dispatcher.h"
+#include "envoy/http/header_map.h"
+#include "envoy/network/address.h"
+#include "envoy/registry/registry.h"
+
+#include "common/api/api_impl.h"
+#include "common/buffer/buffer_impl.h"
+#include "common/common/fmt.h"
+#include "common/common/thread_annotations.h"
+#include "common/http/headers.h"
+#include "common/network/utility.h"
+#include "common/protobuf/utility.h"
+#include "common/runtime/runtime_impl.h"
+#include "common/upstream/upstream_impl.h"
+
+#include "test/common/upstream/utility.h"
+#include "test/integration/autonomous_upstream.h"
+#include "test/integration/test_host_predicate_config.h"
+#include "test/integration/utility.h"
+#include "test/mocks/upstream/mocks.h"
+#include "test/test_common/environment.h"
+#include "test/test_common/network_utility.h"
+#include "test/test_common/registry.h"
+
+#include "gtest/gtest.h"
+
+using testing::_;
+using testing::AnyNumber;
+using testing::HasSubstr;
+using testing::Invoke;
+using testing::Not;
+
+namespace Envoy {
+namespace {
+
+envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager::CodecType
+typeToCodecType(Http::CodecClient::Type type) {
+  switch (type) {
+  case Http::CodecClient::Type::HTTP1:
+    return envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager::
+        HTTP1;
+  case Http::CodecClient::Type::HTTP2:
+    return envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager::
+        HTTP2;
+  default:
+    RELEASE_ASSERT(0, "");
+  }
+}
+
+} // namespace
+
+IntegrationCodecClient::IntegrationCodecClient(
+    Event::Dispatcher& dispatcher, Network::ClientConnectionPtr&& conn,
+    Upstream::HostDescriptionConstSharedPtr host_description, CodecClient::Type type)
+    : CodecClientProd(type, std::move(conn), host_description, dispatcher), dispatcher_(dispatcher),
+      callbacks_(*this), codec_callbacks_(*this) {
+  connection_->addConnectionCallbacks(callbacks_);
+  setCodecConnectionCallbacks(codec_callbacks_);
+  dispatcher.run(Event::Dispatcher::RunType::Block);
+}
+
+void IntegrationCodecClient::flushWrite() {
+  connection_->dispatcher().run(Event::Dispatcher::RunType::NonBlock);
+  // NOTE: We should run blocking until all the body data is flushed.
+}
+
+IntegrationStreamDecoderPtr
+IntegrationCodecClient::makeHeaderOnlyRequest(const Http::HeaderMap& headers) {
+  auto response = std::make_unique<IntegrationStreamDecoder>(dispatcher_);
+  Http::StreamEncoder& encoder = newStream(*response);
+  encoder.getStream().addCallbacks(*response);
+  encoder.encodeHeaders(headers, true);
+  flushWrite();
+  return response;
+}
+
+IntegrationStreamDecoderPtr
+IntegrationCodecClient::makeRequestWithBody(const Http::HeaderMap& headers, uint64_t body_size) {
+  return makeRequestWithBody(headers, std::string(body_size, 'a'));
+}
+
+IntegrationStreamDecoderPtr
+IntegrationCodecClient::makeRequestWithBody(const Http::HeaderMap& headers,
+                                            const std::string& body) {
+  auto response = std::make_unique<IntegrationStreamDecoder>(dispatcher_);
+  Http::StreamEncoder& encoder = newStream(*response);
+  encoder.getStream().addCallbacks(*response);
+  encoder.encodeHeaders(headers, false);
+  Buffer::OwnedImpl data(body);
+  encoder.encodeData(data, true);
+  flushWrite();
+  return response;
+}
+
+void IntegrationCodecClient::sendData(Http::StreamEncoder& encoder, absl::string_view data,
+                                      bool end_stream) {
+  Buffer::OwnedImpl buffer_data(data.data(), data.size());
+  encoder.encodeData(buffer_data, end_stream);
+  flushWrite();
+}
+
+void IntegrationCodecClient::sendData(Http::StreamEncoder& encoder, Buffer::Instance& data,
+                                      bool end_stream) {
+  encoder.encodeData(data, end_stream);
+  flushWrite();
+}
+
+void IntegrationCodecClient::sendData(Http::StreamEncoder& encoder, uint64_t size,
+                                      bool end_stream) {
+  Buffer::OwnedImpl data(std::string(size, 'a'));
+  sendData(encoder, data, end_stream);
+}
+
+void IntegrationCodecClient::sendTrailers(Http::StreamEncoder& encoder,
+                                          const Http::HeaderMap& trailers) {
+  encoder.encodeTrailers(trailers);
+  flushWrite();
+}
+
+void IntegrationCodecClient::sendReset(Http::StreamEncoder& encoder) {
+  encoder.getStream().resetStream(Http::StreamResetReason::LocalReset);
+  flushWrite();
+}
+
+std::pair<Http::StreamEncoder&, IntegrationStreamDecoderPtr>
+IntegrationCodecClient::startRequest(const Http::HeaderMap& headers) {
+  auto response = std::make_unique<IntegrationStreamDecoder>(dispatcher_);
+  Http::StreamEncoder& encoder = newStream(*response);
+  encoder.getStream().addCallbacks(*response);
+  encoder.encodeHeaders(headers, false);
+  flushWrite();
+  return {encoder, std::move(response)};
+}
+
+bool IntegrationCodecClient::waitForDisconnect(std::chrono::milliseconds time_to_wait) {
+  Event::TimerPtr wait_timer;
+  bool wait_timer_triggered = false;
+  if (time_to_wait.count()) {
+    wait_timer = connection_->dispatcher().createTimer([this, &wait_timer_triggered] {
+      connection_->dispatcher().exit();
+      wait_timer_triggered = true;
+    });
+    wait_timer->enableTimer(time_to_wait);
+  }
+
+  connection_->dispatcher().run(Event::Dispatcher::RunType::Block);
+
+  // Disable the timer if it was created. This call is harmless if the timer already triggered.
+  if (wait_timer) {
+    wait_timer->disableTimer();
+  }
+
+  if (wait_timer_triggered && !disconnected_) {
+    return false;
+  }
+  EXPECT_TRUE(disconnected_);
+
+  return true;
+}
+
+void IntegrationCodecClient::ConnectionCallbacks::onEvent(Network::ConnectionEvent event) {
+  parent_.last_connection_event_ = event;
+  if (event == Network::ConnectionEvent::Connected) {
+    parent_.connected_ = true;
+    parent_.connection_->dispatcher().exit();
+  } else if (event == Network::ConnectionEvent::RemoteClose) {
+    parent_.disconnected_ = true;
+    parent_.connection_->dispatcher().exit();
+  } else {
+    parent_.disconnected_ = true;
+  }
+}
+
+IntegrationCodecClientPtr HttpIntegrationTest::makeHttpConnection(uint32_t port) {
+  return makeHttpConnection(makeClientConnection(port));
+}
+
+IntegrationCodecClientPtr
+HttpIntegrationTest::makeRawHttpConnection(Network::ClientConnectionPtr&& conn) {
+  std::shared_ptr<Upstream::MockClusterInfo> cluster{new NiceMock<Upstream::MockClusterInfo>()};
+  cluster->max_response_headers_count_ = 200;
+  cluster->http2_settings_.allow_connect_ = true;
+  cluster->http2_settings_.allow_metadata_ = true;
+  Upstream::HostDescriptionConstSharedPtr host_description{Upstream::makeTestHostDescription(
+      cluster, fmt::format("tcp://{}:80", Network::Test::getLoopbackAddressUrlString(version_)))};
+  return std::make_unique<IntegrationCodecClient>(*dispatcher_, std::move(conn), host_description,
+                                                  downstream_protocol_);
+}
+
+IntegrationCodecClientPtr
+HttpIntegrationTest::makeHttpConnection(Network::ClientConnectionPtr&& conn) {
+  auto codec = makeRawHttpConnection(std::move(conn));
+  EXPECT_TRUE(codec->connected());
+  return codec;
+}
+
+HttpIntegrationTest::HttpIntegrationTest(Http::CodecClient::Type downstream_protocol,
+                                         Network::Address::IpVersion version,
+                                         const std::string& config)
+    : HttpIntegrationTest::HttpIntegrationTest(
+          downstream_protocol,
+          [version](int) {
+            return Network::Utility::parseInternetAddress(
+                Network::Test::getAnyAddressString(version), 0);
+          },
+          version, config) {}
+
+HttpIntegrationTest::HttpIntegrationTest(Http::CodecClient::Type downstream_protocol,
+                                         const InstanceConstSharedPtrFn& upstream_address_fn,
+                                         Network::Address::IpVersion version,
+                                         const std::string& config)
+    : BaseIntegrationTest(upstream_address_fn, version, config),
+      downstream_protocol_(downstream_protocol) {
+  // Legacy integration tests expect the default listener to be named "http" for
+  // lookupPort calls.
+  config_helper_.renameListener("http");
+  config_helper_.setClientCodec(typeToCodecType(downstream_protocol_));
+}
+
+void HttpIntegrationTest::useAccessLog() {
+  access_log_name_ = TestEnvironment::temporaryPath(TestUtility::uniqueFilename());
+  ASSERT_TRUE(config_helper_.setAccessLog(access_log_name_));
+}
+
+HttpIntegrationTest::~HttpIntegrationTest() {
+  cleanupUpstreamAndDownstream();
+  test_server_.reset();
+  fake_upstreams_.clear();
+}
+
+std::string HttpIntegrationTest::waitForAccessLog(const std::string& filename) {
+  // Wait a max of 1s for logs to flush to disk.
+  for (int i = 0; i < 1000; ++i) {
+    std::string contents = TestEnvironment::readFileToStringForTest(filename, false);
+    if (contents.length() > 0) {
+      return contents;
+    }
+    usleep(1000);
+  }
+  RELEASE_ASSERT(0, "Timed out waiting for access log");
+  return "";
+}
+
+void HttpIntegrationTest::setDownstreamProtocol(Http::CodecClient::Type downstream_protocol) {
+  downstream_protocol_ = downstream_protocol;
+  config_helper_.setClientCodec(typeToCodecType(downstream_protocol_));
+}
+
+IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
+    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
+    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,
+    std::chrono::milliseconds time) {
+  ASSERT(codec_client_ != nullptr);
+  // Send the request to Envoy.
+  IntegrationStreamDecoderPtr response;
+  if (request_body_size) {
+    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
+  } else {
+    response = codec_client_->makeHeaderOnlyRequest(request_headers);
+  }
+  waitForNextUpstreamRequest(upstream_index, time);
+  // Send response headers, and end_stream if there is no response body.
+  upstream_request_->encodeHeaders(response_headers, response_size == 0);
+  // Send any response data, with end_stream true.
+  if (response_size) {
+    upstream_request_->encodeData(response_size, true);
+  }
+  // Wait for the response to be read by the codec client.
+  response->waitForEndStream();
+  return response;
+}
+
+void HttpIntegrationTest::cleanupUpstreamAndDownstream() {
+  // Close the upstream connection first. If there's an outstanding request,
+  // closing the client may result in a FIN being sent upstream, and FakeConnectionBase::close
+  // will interpret that as an unexpected disconnect. The codec client is not
+  // subject to the same failure mode.
+  if (fake_upstream_connection_) {
+    AssertionResult result = fake_upstream_connection_->close();
+    RELEASE_ASSERT(result, result.message());
+    result = fake_upstream_connection_->waitForDisconnect();
+    RELEASE_ASSERT(result, result.message());
+    fake_upstream_connection_.reset();
+  }
+  if (codec_client_) {
+    codec_client_->close();
+  }
+}
+
+uint64_t
+HttpIntegrationTest::waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices,
+                                                std::chrono::milliseconds connection_wait_timeout) {
+  uint64_t upstream_with_request;
+  // If there is no upstream connection, wait for it to be established.
+  if (!fake_upstream_connection_) {
+    AssertionResult result = AssertionFailure();
+    for (auto upstream_index : upstream_indices) {
+      result = fake_upstreams_[upstream_index]->waitForHttpConnection(
+          *dispatcher_, fake_upstream_connection_, connection_wait_timeout,
+          max_request_headers_kb_, max_request_headers_count_);
+      if (result) {
+        upstream_with_request = upstream_index;
+        break;
+      }
+    }
+    RELEASE_ASSERT(result, result.message());
+  }
+  // Wait for the next stream on the upstream connection.
+  AssertionResult result =
+      fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_);
+  RELEASE_ASSERT(result, result.message());
+  // Wait for the stream to be completely received.
+  result = upstream_request_->waitForEndStream(*dispatcher_);
+  RELEASE_ASSERT(result, result.message());
+
+  return upstream_with_request;
+}
+
+void HttpIntegrationTest::waitForNextUpstreamRequest(
+    uint64_t upstream_index, std::chrono::milliseconds connection_wait_timeout) {
+  waitForNextUpstreamRequest(std::vector<uint64_t>({upstream_index}), connection_wait_timeout);
+}
+
+void HttpIntegrationTest::addFilters(std::vector<std::string> filters) {
+  for (const auto& filter : filters) {
+    config_helper_.addFilter(filter);
+  }
+}
+
+void HttpIntegrationTest::checkSimpleRequestSuccess(uint64_t expected_request_size,
+                                                    uint64_t expected_response_size,
+                                                    IntegrationStreamDecoder* response) {
+  EXPECT_TRUE(upstream_request_->complete());
+  EXPECT_EQ(expected_request_size, upstream_request_->bodyLength());
+
+  ASSERT_TRUE(response->complete());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  EXPECT_EQ(expected_response_size, response->body().size());
+}
+
+void HttpIntegrationTest::testRouterRequestAndResponseWithBody(
+    uint64_t request_size, uint64_t response_size, bool big_header,
+    ConnectionCreationFunction* create_connection) {
+  initialize();
+  codec_client_ = makeHttpConnection(
+      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort("http"))));
+  Http::TestHeaderMapImpl request_headers{
+      {":method", "POST"},    {":path", "/test/long/url"}, {":scheme", "http"},
+      {":authority", "host"}, {"x-lyft-user-id", "123"},   {"x-forwarded-for", "10.0.0.1"}};
+  if (big_header) {
+    request_headers.addCopy("big", std::string(4096, 'a'));
+  }
+  auto response = sendRequestAndWaitForResponse(request_headers, request_size,
+                                                default_response_headers_, response_size);
+  checkSimpleRequestSuccess(request_size, response_size, response.get());
+}
+
+IntegrationStreamDecoderPtr
+HttpIntegrationTest::makeHeaderOnlyRequest(ConnectionCreationFunction* create_connection,
+                                           int upstream_index, const std::string& path,
+                                           const std::string& authority) {
+  // This is called multiple times per test in ads_integration_test. Only call
+  // initialize() the first time.
+  if (!initialized()) {
+    initialize();
+  }
+  codec_client_ = makeHttpConnection(
+      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort("http"))));
+  Http::TestHeaderMapImpl request_headers{{":method", "GET"},
+                                          {":path", path},
+                                          {":scheme", "http"},
+                                          {":authority", authority},
+                                          {"x-lyft-user-id", "123"}};
+  return sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0,
+                                       upstream_index);
+}
+
+void HttpIntegrationTest::testRouterHeaderOnlyRequestAndResponse(
+    ConnectionCreationFunction* create_connection, int upstream_index, const std::string& path,
+    const std::string& authority) {
+  auto response = makeHeaderOnlyRequest(create_connection, upstream_index, path, authority);
+  checkSimpleRequestSuccess(0U, 0U, response.get());
+}
+
+// Change the default route to be restrictive, and send a request to an alternate route.
+void HttpIntegrationTest::testRouterNotFound() {
+  config_helper_.setDefaultHostAndRoute("foo.com", "/found");
+  initialize();
+
+  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(
+      lookupPort("http"), "GET", "/notfound", "", downstream_protocol_, version_);
+  ASSERT_TRUE(response->complete());
+  EXPECT_EQ("404", response->headers().Status()->value().getStringView());
+}
+
+// Change the default route to be restrictive, and send a POST to an alternate route.
+void HttpIntegrationTest::testRouterNotFoundWithBody() {
+  config_helper_.setDefaultHostAndRoute("foo.com", "/found");
+  initialize();
+
+  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(
+      lookupPort("http"), "POST", "/notfound", "foo", downstream_protocol_, version_);
+  ASSERT_TRUE(response->complete());
+  EXPECT_EQ("404", response->headers().Status()->value().getStringView());
+}
+
+void HttpIntegrationTest::testRouterUpstreamDisconnectBeforeRequestComplete() {
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+
+  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);
+  auto response = std::move(encoder_decoder.second);
+
+  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));
+
+  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));
+  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());
+  ASSERT_TRUE(fake_upstream_connection_->close());
+  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+  response->waitForEndStream();
+
+  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {
+    codec_client_->waitForDisconnect();
+  } else {
+    codec_client_->close();
+  }
+
+  EXPECT_FALSE(upstream_request_->complete());
+  EXPECT_EQ(0U, upstream_request_->bodyLength());
+
+  EXPECT_TRUE(response->complete());
+  EXPECT_EQ("503", response->headers().Status()->value().getStringView());
+  EXPECT_EQ("upstream connect error or disconnect/reset before headers. reset reason: connection "
+            "termination",
+            response->body());
+}
+
+void HttpIntegrationTest::testRouterUpstreamDisconnectBeforeResponseComplete(
+    ConnectionCreationFunction* create_connection) {
+  initialize();
+  codec_client_ = makeHttpConnection(
+      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort("http"))));
+  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
+  waitForNextUpstreamRequest();
+  upstream_request_->encodeHeaders(default_response_headers_, false);
+  ASSERT_TRUE(fake_upstream_connection_->close());
+  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+
+  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {
+    codec_client_->waitForDisconnect();
+  } else {
+    response->waitForReset();
+    codec_client_->close();
+  }
+
+  EXPECT_TRUE(upstream_request_->complete());
+  EXPECT_EQ(0U, upstream_request_->bodyLength());
+
+  EXPECT_FALSE(response->complete());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  EXPECT_EQ(0U, response->body().size());
+}
+
+void HttpIntegrationTest::testRouterDownstreamDisconnectBeforeRequestComplete(
+    ConnectionCreationFunction* create_connection) {
+  initialize();
+
+  codec_client_ = makeHttpConnection(
+      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort("http"))));
+  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);
+  auto response = std::move(encoder_decoder.second);
+  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));
+  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));
+  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());
+  codec_client_->close();
+
+  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {
+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+  } else {
+    ASSERT_TRUE(upstream_request_->waitForReset());
+    ASSERT_TRUE(fake_upstream_connection_->close());
+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+  }
+
+  EXPECT_FALSE(upstream_request_->complete());
+  EXPECT_EQ(0U, upstream_request_->bodyLength());
+
+  EXPECT_FALSE(response->complete());
+}
+
+void HttpIntegrationTest::testRouterDownstreamDisconnectBeforeResponseComplete(
+    ConnectionCreationFunction* create_connection) {
+#ifdef __APPLE__
+  // Skip this test on macOS: we can't detect the early close on macOS, and we
+  // won't clean up the upstream connection until it times out. See #4294.
+  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {
+    return;
+  }
+#endif
+  initialize();
+  codec_client_ = makeHttpConnection(
+      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort("http"))));
+  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
+  waitForNextUpstreamRequest();
+  upstream_request_->encodeHeaders(default_response_headers_, false);
+  upstream_request_->encodeData(512, false);
+  response->waitForBodyData(512);
+  codec_client_->close();
+
+  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {
+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+  } else {
+    ASSERT_TRUE(upstream_request_->waitForReset());
+    ASSERT_TRUE(fake_upstream_connection_->close());
+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+  }
+
+  EXPECT_TRUE(upstream_request_->complete());
+  EXPECT_EQ(0U, upstream_request_->bodyLength());
+
+  EXPECT_FALSE(response->complete());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  EXPECT_EQ(512U, response->body().size());
+}
+
+void HttpIntegrationTest::testRouterUpstreamResponseBeforeRequestComplete() {
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);
+  auto response = std::move(encoder_decoder.second);
+  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));
+  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));
+  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());
+  upstream_request_->encodeHeaders(default_response_headers_, false);
+  upstream_request_->encodeData(512, true);
+  response->waitForEndStream();
+
+  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {
+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+  } else {
+    ASSERT_TRUE(upstream_request_->waitForReset());
+    ASSERT_TRUE(fake_upstream_connection_->close());
+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+  }
+
+  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {
+    codec_client_->waitForDisconnect();
+  } else {
+    codec_client_->close();
+  }
+
+  EXPECT_FALSE(upstream_request_->complete());
+  EXPECT_EQ(0U, upstream_request_->bodyLength());
+
+  EXPECT_TRUE(response->complete());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  EXPECT_EQ(512U, response->body().size());
+}
+
+void HttpIntegrationTest::testRetry() {
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+  auto response =
+      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{":method", "POST"},
+                                                                 {":path", "/test/long/url"},
+                                                                 {":scheme", "http"},
+                                                                 {":authority", "host"},
+                                                                 {"x-forwarded-for", "10.0.0.1"},
+                                                                 {"x-envoy-retry-on", "5xx"}},
+                                         1024);
+  waitForNextUpstreamRequest();
+  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{":status", "503"}}, false);
+
+  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {
+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));
+  } else {
+    ASSERT_TRUE(upstream_request_->waitForReset());
+  }
+  waitForNextUpstreamRequest();
+  upstream_request_->encodeHeaders(default_response_headers_, false);
+  upstream_request_->encodeData(512, true);
+
+  response->waitForEndStream();
+  EXPECT_TRUE(upstream_request_->complete());
+  EXPECT_EQ(1024U, upstream_request_->bodyLength());
+
+  EXPECT_TRUE(response->complete());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  EXPECT_EQ(512U, response->body().size());
+}
+
+// Tests that the x-envoy-attempt-count header is properly set on the upstream request
+// and updated after the request is retried.
+void HttpIntegrationTest::testRetryAttemptCountHeader() {
+  auto host = config_helper_.createVirtualHost("host", "/test_retry");
+  host.set_include_request_attempt_count(true);
+  config_helper_.addVirtualHost(host);
+
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+  auto response =
+      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{":method", "POST"},
+                                                                 {":path", "/test_retry"},
+                                                                 {":scheme", "http"},
+                                                                 {":authority", "host"},
+                                                                 {"x-forwarded-for", "10.0.0.1"},
+                                                                 {"x-envoy-retry-on", "5xx"}},
+                                         1024);
+  waitForNextUpstreamRequest();
+  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{":status", "503"}}, false);
+
+  EXPECT_EQ(
+      atoi(std::string(upstream_request_->headers().EnvoyAttemptCount()->value().getStringView())
+               .c_str()),
+      1);
+
+  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {
+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));
+  } else {
+    ASSERT_TRUE(upstream_request_->waitForReset());
+  }
+  waitForNextUpstreamRequest();
+  EXPECT_EQ(
+      atoi(std::string(upstream_request_->headers().EnvoyAttemptCount()->value().getStringView())
+               .c_str()),
+      2);
+  upstream_request_->encodeHeaders(default_response_headers_, false);
+  upstream_request_->encodeData(512, true);
+
+  response->waitForEndStream();
+  EXPECT_TRUE(upstream_request_->complete());
+  EXPECT_EQ(1024U, upstream_request_->bodyLength());
+
+  EXPECT_TRUE(response->complete());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  EXPECT_EQ(512U, response->body().size());
+}
+
+void HttpIntegrationTest::testGrpcRetry() {
+  Http::TestHeaderMapImpl response_trailers{{"response1", "trailer1"}, {"grpc-status", "0"}};
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+  auto encoder_decoder =
+      codec_client_->startRequest(Http::TestHeaderMapImpl{{":method", "POST"},
+                                                          {":path", "/test/long/url"},
+                                                          {":scheme", "http"},
+                                                          {":authority", "host"},
+                                                          {"x-forwarded-for", "10.0.0.1"},
+                                                          {"x-envoy-retry-grpc-on", "cancelled"}});
+  request_encoder_ = &encoder_decoder.first;
+  auto response = std::move(encoder_decoder.second);
+  codec_client_->sendData(*request_encoder_, 1024, true);
+  waitForNextUpstreamRequest();
+  upstream_request_->encodeHeaders(
+      Http::TestHeaderMapImpl{{":status", "200"}, {"grpc-status", "1"}}, false);
+  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {
+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));
+  } else {
+    ASSERT_TRUE(upstream_request_->waitForReset());
+  }
+  waitForNextUpstreamRequest();
+
+  upstream_request_->encodeHeaders(default_response_headers_, false);
+  upstream_request_->encodeData(512,
+                                fake_upstreams_[0]->httpType() != FakeHttpConnection::Type::HTTP2);
+  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP2) {
+    upstream_request_->encodeTrailers(response_trailers);
+  }
+
+  response->waitForEndStream();
+  EXPECT_TRUE(upstream_request_->complete());
+  EXPECT_EQ(1024U, upstream_request_->bodyLength());
+
+  EXPECT_TRUE(response->complete());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  EXPECT_EQ(512U, response->body().size());
+  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP2) {
+    EXPECT_THAT(*response->trailers(), HeaderMapEqualRef(&response_trailers));
+  }
+}
+
+void HttpIntegrationTest::testEnvoyHandling100Continue(bool additional_continue_from_upstream,
+                                                       const std::string& via) {
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+
+  auto encoder_decoder =
+      codec_client_->startRequest(Http::TestHeaderMapImpl{{":method", "POST"},
+                                                          {":path", "/dynamo/url"},
+                                                          {":scheme", "http"},
+                                                          {":authority", "host"},
+                                                          {"expect", "100-continue"}});
+  request_encoder_ = &encoder_decoder.first;
+  auto response = std::move(encoder_decoder.second);
+  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));
+  // The continue headers should arrive immediately.
+  response->waitForContinueHeaders();
+  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));
+
+  // Send the rest of the request.
+  codec_client_->sendData(*request_encoder_, 10, true);
+  ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));
+  // Verify the Expect header is stripped.
+  EXPECT_EQ(nullptr, upstream_request_->headers().get(Http::Headers::get().Expect));
+  if (via.empty()) {
+    EXPECT_EQ(nullptr, upstream_request_->headers().get(Http::Headers::get().Via));
+  } else {
+    EXPECT_EQ(via,
+              upstream_request_->headers().get(Http::Headers::get().Via)->value().getStringView());
+  }
+
+  if (additional_continue_from_upstream) {
+    // Make sure if upstream sends an 100-Continue Envoy doesn't send its own and proxy the one
+    // from upstream!
+    upstream_request_->encode100ContinueHeaders(Http::TestHeaderMapImpl{{":status", "100"}});
+  }
+  upstream_request_->encodeHeaders(default_response_headers_, false);
+  upstream_request_->encodeData(12, true);
+
+  response->waitForEndStream();
+  ASSERT_TRUE(response->complete());
+  ASSERT(response->continue_headers() != nullptr);
+  EXPECT_EQ("100", response->continue_headers()->Status()->value().getStringView());
+  EXPECT_EQ(nullptr, response->continue_headers()->Via());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  if (via.empty()) {
+    EXPECT_EQ(nullptr, response->headers().Via());
+  } else {
+    EXPECT_EQ(via.c_str(), response->headers().Via()->value().getStringView());
+  }
+}
+
+void HttpIntegrationTest::testEnvoyProxying100Continue(bool continue_before_upstream_complete,
+                                                       bool with_encoder_filter) {
+  if (with_encoder_filter) {
+    // Because 100-continue only affects encoder filters, make sure it plays well with one.
+    config_helper_.addFilter("name: envoy.cors");
+    config_helper_.addConfigModifier(
+        [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)
+            -> void {
+          auto* route_config = hcm.mutable_route_config();
+          auto* virtual_host = route_config->mutable_virtual_hosts(0);
+          {
+            auto* cors = virtual_host->mutable_cors();
+            cors->add_allow_origin("*");
+            cors->set_allow_headers("content-type,x-grpc-web");
+            cors->set_allow_methods("GET,POST");
+          }
+        });
+  }
+  config_helper_.addConfigModifier(
+      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)
+          -> void { hcm.set_proxy_100_continue(true); });
+  initialize();
+
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+  auto encoder_decoder =
+      codec_client_->startRequest(Http::TestHeaderMapImpl{{":method", "GET"},
+                                                          {":path", "/dynamo/url"},
+                                                          {":scheme", "http"},
+                                                          {":authority", "host"},
+                                                          {"expect", "100-continue"}});
+  request_encoder_ = &encoder_decoder.first;
+  auto response = std::move(encoder_decoder.second);
+
+  // Wait for the request headers to be received upstream.
+  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));
+  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));
+
+  if (continue_before_upstream_complete) {
+    // This case tests sending on 100-Continue headers before the client has sent all the
+    // request data.
+    upstream_request_->encode100ContinueHeaders(Http::TestHeaderMapImpl{{":status", "100"}});
+    response->waitForContinueHeaders();
+  }
+  // Send all of the request data and wait for it to be received upstream.
+  codec_client_->sendData(*request_encoder_, 10, true);
+  ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));
+
+  if (!continue_before_upstream_complete) {
+    // This case tests forwarding 100-Continue after the client has sent all data.
+    upstream_request_->encode100ContinueHeaders(Http::TestHeaderMapImpl{{":status", "100"}});
+    response->waitForContinueHeaders();
+  }
+  // Now send the rest of the response.
+  upstream_request_->encodeHeaders(default_response_headers_, true);
+  response->waitForEndStream();
+  EXPECT_TRUE(response->complete());
+  ASSERT(response->continue_headers() != nullptr);
+  EXPECT_EQ("100", response->continue_headers()->Status()->value().getStringView());
+
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+}
+
+void HttpIntegrationTest::testTwoRequests(bool network_backup) {
+  // if network_backup is false, this simply tests that Envoy can handle multiple
+  // requests on a connection.
+  //
+  // If network_backup is true, the first request will explicitly set the TCP level flow control
+  // as blocked as it finishes the encode and set a timer to unblock. The second stream should be
+  // created while the socket appears to be in the high watermark state, and regression tests that
+  // flow control will be corrected as the socket "becomes unblocked"
+  if (network_backup) {
+    config_helper_.addFilter(R"EOF(
+  name: pause-filter
+  config: {}
+  )EOF");
+  }
+  initialize();
+
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+
+  // Request 1.
+  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 1024);
+  waitForNextUpstreamRequest();
+
+  upstream_request_->encodeHeaders(default_response_headers_, false);
+  upstream_request_->encodeData(512, true);
+  response->waitForEndStream();
+
+  EXPECT_TRUE(upstream_request_->complete());
+  EXPECT_EQ(1024U, upstream_request_->bodyLength());
+  EXPECT_TRUE(response->complete());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  EXPECT_EQ(512U, response->body().size());
+
+  // Request 2.
+  response = codec_client_->makeRequestWithBody(default_request_headers_, 512);
+  waitForNextUpstreamRequest();
+  upstream_request_->encodeHeaders(default_response_headers_, false);
+  upstream_request_->encodeData(1024, true);
+  response->waitForEndStream();
+
+  EXPECT_TRUE(upstream_request_->complete());
+  EXPECT_EQ(512U, upstream_request_->bodyLength());
+  EXPECT_TRUE(response->complete());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  EXPECT_EQ(1024U, response->body().size());
+}
+
+void HttpIntegrationTest::testLargeRequestHeaders(uint32_t size, uint32_t count, uint32_t max_size,
+                                                  uint32_t max_count) {
+  // `size` parameter dictates the size of each header that will be added to the request and `count`
+  // parameter is the number of headers to be added. The actual request byte size will exceed `size`
+  // due to the keys and other headers. The actual request header count will exceed `count` by four
+  // due to default headers.
+
+  config_helper_.addConfigModifier(
+      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)
+          -> void {
+        hcm.mutable_max_request_headers_kb()->set_value(max_size);
+        hcm.mutable_common_http_protocol_options()->mutable_max_headers_count()->set_value(
+            max_count);
+      });
+  max_request_headers_kb_ = max_size;
+  max_request_headers_count_ = max_count;
+
+  Http::TestHeaderMapImpl big_headers{
+      {":method", "GET"}, {":path", "/test/long/url"}, {":scheme", "http"}, {":authority", "host"}};
+  // Already added four headers.
+  for (unsigned int i = 0; i < count; i++) {
+    big_headers.addCopy(std::to_string(i), std::string(size * 1024, 'a'));
+  }
+
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+  if (size >= max_size || count > max_count) {
+    // header size includes keys too, so expect rejection when equal
+    auto encoder_decoder = codec_client_->startRequest(big_headers);
+    auto response = std::move(encoder_decoder.second);
+
+    if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {
+      codec_client_->waitForDisconnect();
+      EXPECT_TRUE(response->complete());
+      EXPECT_EQ("431", response->headers().Status()->value().getStringView());
+    } else {
+      response->waitForReset();
+      codec_client_->close();
+    }
+  } else {
+    auto response = sendRequestAndWaitForResponse(big_headers, 0, default_response_headers_, 0);
+    EXPECT_TRUE(response->complete());
+    EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  }
+}
+
+void HttpIntegrationTest::testLargeRequestTrailers(uint32_t size, uint32_t max_size) {
+  // `size` parameter is the size of the trailer that will be added to the
+  // request. The actual request byte size will exceed `size` due to keys
+  // and other headers.
+
+  config_helper_.addConfigModifier(
+      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)
+          -> void { hcm.mutable_max_request_headers_kb()->set_value(max_size); });
+  max_request_headers_kb_ = max_size;
+  Http::TestHeaderMapImpl request_trailers{{"trailer", "trailer"}};
+  request_trailers.addCopy("big", std::string(size * 1024, 'a'));
+
+  initialize();
+
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);
+
+  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);
+  request_encoder_ = &encoder_decoder.first;
+  auto response = std::move(encoder_decoder.second);
+  codec_client_->sendData(*request_encoder_, 10, false);
+  codec_client_->sendTrailers(*request_encoder_, request_trailers);
+
+  if (size >= max_size && downstream_protocol_ == Http::CodecClient::Type::HTTP2) {
+    // For HTTP/2, expect a stream reset when the size of the trailers is larger than the maximum
+    // limit.
+    response->waitForReset();
+    codec_client_->close();
+    EXPECT_FALSE(response->complete());
+
+  } else {
+    waitForNextUpstreamRequest();
+    upstream_request_->encodeHeaders(default_response_headers_, true);
+    response->waitForEndStream();
+    EXPECT_TRUE(response->complete());
+  }
+}
+
+void HttpIntegrationTest::testManyRequestHeaders(std::chrono::milliseconds time) {
+  config_helper_.addConfigModifier(
+      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)
+          -> void {
+        hcm.mutable_max_request_headers_kb()->set_value(96);
+        hcm.mutable_common_http_protocol_options()->mutable_max_headers_count()->set_value(20100);
+      });
+  max_request_headers_kb_ = 96;
+  max_request_headers_count_ = 201000;
+
+  Http::TestHeaderMapImpl big_headers{
+      {":method", "GET"}, {":path", "/test/long/url"}, {":scheme", "http"}, {":authority", "host"}};
+
+  for (int i = 0; i < 20000; i++) {
+    big_headers.addCopy(std::to_string(i), std::string(0, 'a'));
+  }
+  initialize();
+
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+
+  auto response =
+      sendRequestAndWaitForResponse(big_headers, 0, default_response_headers_, 0, 0, time);
+
+  EXPECT_TRUE(response->complete());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+}
+
+void HttpIntegrationTest::testDownstreamResetBeforeResponseComplete() {
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+
+  auto encoder_decoder =
+      codec_client_->startRequest(Http::TestHeaderMapImpl{{":method", "GET"},
+                                                          {":path", "/test/long/url"},
+                                                          {":scheme", "http"},
+                                                          {":authority", "host"},
+                                                          {"cookie", "a=b"},
+                                                          {"cookie", "c=d"}});
+  request_encoder_ = &encoder_decoder.first;
+  auto response = std::move(encoder_decoder.second);
+  codec_client_->sendData(*request_encoder_, 0, true);
+  waitForNextUpstreamRequest();
+
+  EXPECT_EQ(upstream_request_->headers().get(Http::Headers::get().Cookie)->value(), "a=b; c=d");
+
+  upstream_request_->encodeHeaders(default_response_headers_, false);
+  upstream_request_->encodeData(512, false);
+
+  response->waitForBodyData(512);
+  codec_client_->sendReset(*request_encoder_);
+
+  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {
+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+  } else {
+    ASSERT_TRUE(upstream_request_->waitForReset());
+    ASSERT_TRUE(fake_upstream_connection_->close());
+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+  }
+
+  codec_client_->close();
+
+  EXPECT_TRUE(upstream_request_->complete());
+  EXPECT_EQ(0U, upstream_request_->bodyLength());
+
+  EXPECT_FALSE(response->complete());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  EXPECT_EQ(512U, response->body().size());
+}
+
+void HttpIntegrationTest::testTrailers(uint64_t request_size, uint64_t response_size) {
+  Http::TestHeaderMapImpl request_trailers{{"request1", "trailer1"}, {"request2", "trailer2"}};
+  Http::TestHeaderMapImpl response_trailers{{"response1", "trailer1"}, {"response2", "trailer2"}};
+
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+  auto encoder_decoder =
+      codec_client_->startRequest(Http::TestHeaderMapImpl{{":method", "POST"},
+                                                          {":path", "/test/long/url"},
+                                                          {":scheme", "http"},
+                                                          {":authority", "host"}});
+  request_encoder_ = &encoder_decoder.first;
+  auto response = std::move(encoder_decoder.second);
+  codec_client_->sendData(*request_encoder_, request_size, false);
+  codec_client_->sendTrailers(*request_encoder_, request_trailers);
+  waitForNextUpstreamRequest();
+  upstream_request_->encodeHeaders(default_response_headers_, false);
+  upstream_request_->encodeData(response_size, false);
+  upstream_request_->encodeTrailers(response_trailers);
+  response->waitForEndStream();
+
+  EXPECT_TRUE(upstream_request_->complete());
+  EXPECT_EQ(request_size, upstream_request_->bodyLength());
+  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP2) {
+    EXPECT_THAT(*upstream_request_->trailers(), HeaderMapEqualRef(&request_trailers));
+  }
+
+  EXPECT_TRUE(response->complete());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  EXPECT_EQ(response_size, response->body().size());
+  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP2) {
+    EXPECT_THAT(*response->trailers(), HeaderMapEqualRef(&response_trailers));
+  }
+}
+
+std::string HttpIntegrationTest::listenerStatPrefix(const std::string& stat_name) {
+  if (version_ == Network::Address::IpVersion::v4) {
+    return "listener.127.0.0.1_0." + stat_name;
+  }
+  return "listener.[__1]_0." + stat_name;
+}
+} // namespace Envoy
diff --git a/test/integration/autonomous_upstream.cc b/test/integration/autonomous_upstream.cc
index 1ac10254d..bd00fd176 100644
--- a/test/integration/autonomous_upstream.cc
+++ b/test/integration/autonomous_upstream.cc
@@ -63,7 +63,7 @@ AutonomousHttpConnection::AutonomousHttpConnection(SharedConnectionWrapper& shar
                                                    Stats::Store& store, Type type,
                                                    AutonomousUpstream& upstream)
     : FakeHttpConnection(shared_connection, store, type, upstream.timeSystem(),
-                         Http::DEFAULT_MAX_REQUEST_HEADERS_KB),
+                         Http::DEFAULT_MAX_REQUEST_HEADERS_KB, Http::DEFAULT_MAX_HEADERS_COUNT),
       upstream_(upstream) {}
 
 Http::StreamDecoder& AutonomousHttpConnection::newStream(Http::StreamEncoder& response_encoder,
diff --git a/test/integration/fake_upstream.cc b/test/integration/fake_upstream.cc
index 546f159fa..6025daf90 100644
--- a/test/integration/fake_upstream.cc
+++ b/test/integration/fake_upstream.cc
@@ -209,17 +209,20 @@ void FakeStream::finishGrpcStream(Grpc::Status::GrpcStatus status) {
 FakeHttpConnection::FakeHttpConnection(SharedConnectionWrapper& shared_connection,
                                        Stats::Store& store, Type type,
                                        Event::TestTimeSystem& time_system,
-                                       uint32_t max_request_headers_kb)
+                                       uint32_t max_request_headers_kb,
+                                       uint32_t max_request_headers_count)
     : FakeConnectionBase(shared_connection, time_system) {
   if (type == Type::HTTP1) {
     codec_ = std::make_unique<Http::Http1::ServerConnectionImpl>(
-        shared_connection_.connection(), *this, Http::Http1Settings(), max_request_headers_kb);
+        shared_connection_.connection(), *this, Http::Http1Settings(), max_request_headers_kb,
+        max_request_headers_count);
   } else {
     auto settings = Http::Http2Settings();
     settings.allow_connect_ = true;
     settings.allow_metadata_ = true;
     codec_ = std::make_unique<Http::Http2::ServerConnectionImpl>(
-        shared_connection_.connection(), *this, store, settings, max_request_headers_kb);
+        shared_connection_.connection(), *this, store, settings, max_request_headers_kb,
+        max_request_headers_count);
     ASSERT(type == Type::HTTP2);
   }
 
@@ -438,7 +441,8 @@ void FakeUpstream::threadRoutine() {
 AssertionResult FakeUpstream::waitForHttpConnection(Event::Dispatcher& client_dispatcher,
                                                     FakeHttpConnectionPtr& connection,
                                                     milliseconds timeout,
-                                                    uint32_t max_request_headers_kb) {
+                                                    uint32_t max_request_headers_kb,
+                                                    uint32_t max_request_headers_count) {
   Event::TestTimeSystem& time_system = timeSystem();
   auto end_time = time_system.monotonicTime() + timeout;
   {
@@ -458,7 +462,8 @@ AssertionResult FakeUpstream::waitForHttpConnection(Event::Dispatcher& client_di
       return AssertionFailure() << "Got a new connection event, but didn't create a connection.";
     }
     connection = std::make_unique<FakeHttpConnection>(consumeConnection(), stats_store_, http_type_,
-                                                      time_system, max_request_headers_kb);
+                                                      time_system, max_request_headers_kb,
+                                                      max_request_headers_count);
   }
   VERIFY_ASSERTION(connection->initialize());
   VERIFY_ASSERTION(connection->readDisable(false));
@@ -488,7 +493,8 @@ FakeUpstream::waitForHttpConnection(Event::Dispatcher& client_dispatcher,
       } else {
         connection = std::make_unique<FakeHttpConnection>(
             upstream.consumeConnection(), upstream.stats_store_, upstream.http_type_,
-            upstream.timeSystem(), Http::DEFAULT_MAX_REQUEST_HEADERS_KB);
+            upstream.timeSystem(), Http::DEFAULT_MAX_REQUEST_HEADERS_KB,
+            Http::DEFAULT_MAX_HEADERS_COUNT);
         lock.release();
         VERIFY_ASSERTION(connection->initialize());
         VERIFY_ASSERTION(connection->readDisable(false));
diff --git a/test/integration/fake_upstream.h b/test/integration/fake_upstream.h
index 38d66690e..65385627a 100644
--- a/test/integration/fake_upstream.h
+++ b/test/integration/fake_upstream.h
@@ -402,7 +402,8 @@ public:
   enum class Type { HTTP1, HTTP2 };
 
   FakeHttpConnection(SharedConnectionWrapper& shared_connection, Stats::Store& store, Type type,
-                     Event::TestTimeSystem& time_system, uint32_t max_request_headers_kb);
+                     Event::TestTimeSystem& time_system, uint32_t max_request_headers_kb,
+                     uint32_t max_request_headers_count);
 
   // By default waitForNewStream assumes the next event is a new stream and
   // returns AssertionFailure if an unexpected event occurs. If a caller truly
@@ -531,7 +532,8 @@ public:
   testing::AssertionResult
   waitForHttpConnection(Event::Dispatcher& client_dispatcher, FakeHttpConnectionPtr& connection,
                         std::chrono::milliseconds timeout = TestUtility::DefaultTimeout,
-                        uint32_t max_request_headers_kb = Http::DEFAULT_MAX_REQUEST_HEADERS_KB);
+                        uint32_t max_request_headers_kb = Http::DEFAULT_MAX_REQUEST_HEADERS_KB,
+                        uint32_t max_request_headers_count = Http::DEFAULT_MAX_HEADERS_COUNT);
 
   ABSL_MUST_USE_RESULT
   testing::AssertionResult
diff --git a/test/integration/http2_upstream_integration_test.cc b/test/integration/http2_upstream_integration_test.cc
index 15303a0a6..b5716c3fa 100644
--- a/test/integration/http2_upstream_integration_test.cc
+++ b/test/integration/http2_upstream_integration_test.cc
@@ -373,4 +373,67 @@ config:
   EXPECT_TRUE(response->complete());
 }
 
+// Tests the default limit for the number of response headers is 100. Results in a stream reset if
+// exceeds.
+TEST_P(Http2UpstreamIntegrationTest, TestManyResponseHeadersRejected) {
+  // Default limit for response headers is 100.
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+
+  Http::TestHeaderMapImpl many_headers(default_response_headers_);
+  for (int i = 0; i < 100; i++) {
+    many_headers.addCopy("many", std::string(1, 'a'));
+  }
+  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
+  waitForNextUpstreamRequest();
+
+  upstream_request_->encodeHeaders(many_headers, true);
+  response->waitForEndStream();
+  // Upstream stream reset triggered.
+  EXPECT_EQ("503", response->headers().Status()->value().getStringView());
+}
+
+// Tests bootstrap configuration of max response headers.
+TEST_P(Http2UpstreamIntegrationTest, ManyResponseHeadersAccepted) {
+  // Set max response header count to 200.
+  config_helper_.addConfigModifier([](envoy::config::bootstrap::v2::Bootstrap& bootstrap) {
+    auto* static_resources = bootstrap.mutable_static_resources();
+    auto* cluster = static_resources->mutable_clusters(0);
+    auto* http_protocol_options = cluster->mutable_common_http_protocol_options();
+    http_protocol_options->mutable_max_headers_count()->set_value(200);
+  });
+  Http::TestHeaderMapImpl response_headers(default_response_headers_);
+  for (int i = 0; i < 150; i++) {
+    response_headers.addCopy(std::to_string(i), std::string(1, 'a'));
+  }
+
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 1024);
+  waitForNextUpstreamRequest();
+
+  upstream_request_->encodeHeaders(response_headers, false);
+  upstream_request_->encodeData(512, true);
+  response->waitForEndStream();
+
+  EXPECT_TRUE(upstream_request_->complete());
+  EXPECT_TRUE(response->complete());
+}
+
+// Tests that HTTP/2 response headers over 60 kB are rejected and result in a stream reset.
+TEST_P(Http2UpstreamIntegrationTest, LargeResponseHeadersRejected) {
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+
+  Http::TestHeaderMapImpl large_headers(default_response_headers_);
+  large_headers.addCopy("large", std::string(60 * 1024, 'a'));
+  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
+  waitForNextUpstreamRequest();
+
+  upstream_request_->encodeHeaders(large_headers, true);
+  response->waitForEndStream();
+  // Upstream stream reset.
+  EXPECT_EQ("503", response->headers().Status()->value().getStringView());
+}
+
 } // namespace Envoy
diff --git a/test/integration/http2_upstream_integration_test.h b/test/integration/http2_upstream_integration_test.h
index efb55c222..d942f8861 100644
--- a/test/integration/http2_upstream_integration_test.h
+++ b/test/integration/http2_upstream_integration_test.h
@@ -16,6 +16,8 @@ public:
     setUpstreamProtocol(FakeHttpConnection::Type::HTTP2);
   }
 
+  void initialize() override { HttpIntegrationTest::initialize(); }
+
   void bidirectionalStreaming(uint32_t bytes);
   void simultaneousRequest(uint32_t request1_bytes, uint32_t request2_bytes,
                            uint32_t response1_bytes, uint32_t response2_bytes);
diff --git a/test/integration/http_integration.cc b/test/integration/http_integration.cc
index 369173637..107e10e43 100644
--- a/test/integration/http_integration.cc
+++ b/test/integration/http_integration.cc
@@ -188,6 +188,7 @@ IntegrationCodecClientPtr HttpIntegrationTest::makeHttpConnection(uint32_t port)
 IntegrationCodecClientPtr
 HttpIntegrationTest::makeRawHttpConnection(Network::ClientConnectionPtr&& conn) {
   std::shared_ptr<Upstream::MockClusterInfo> cluster{new NiceMock<Upstream::MockClusterInfo>()};
+  cluster->max_response_headers_count_ = 200;
   cluster->http2_settings_.allow_connect_ = true;
   cluster->http2_settings_.allow_metadata_ = true;
   Upstream::HostDescriptionConstSharedPtr host_description{Upstream::makeTestHostDescription(
@@ -305,8 +306,8 @@ HttpIntegrationTest::waitForNextUpstreamRequest(const std::vector<uint64_t>& ups
     AssertionResult result = AssertionFailure();
     for (auto upstream_index : upstream_indices) {
       result = fake_upstreams_[upstream_index]->waitForHttpConnection(
-          *dispatcher_, fake_upstream_connection_, connection_wait_timeout,
-          max_request_headers_kb_);
+          *dispatcher_, fake_upstream_connection_, connection_wait_timeout, max_request_headers_kb_,
+          max_request_headers_count_);
       if (result) {
         upstream_with_request = upstream_index;
         break;
@@ -850,24 +851,33 @@ void HttpIntegrationTest::testTwoRequests(bool network_backup) {
   EXPECT_EQ(1024U, response->body().size());
 }
 
-void HttpIntegrationTest::testLargeRequestHeaders(uint32_t size, uint32_t max_size) {
-  // `size` parameter is the size of the header that will be added to the
-  // request. The actual request byte size will exceed `size` due to keys
-  // and other headers.
+void HttpIntegrationTest::testLargeRequestHeaders(uint32_t size, uint32_t count, uint32_t max_size,
+                                                  uint32_t max_count) {
+  // `size` parameter dictates the size of each header that will be added to the request and `count`
+  // parameter is the number of headers to be added. The actual request byte size will exceed `size`
+  // due to the keys and other headers. The actual request header count will exceed `count` by four
+  // due to default headers.
 
   config_helper_.addConfigModifier(
       [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)
-          -> void { hcm.mutable_max_request_headers_kb()->set_value(max_size); });
+          -> void {
+        hcm.mutable_max_request_headers_kb()->set_value(max_size);
+        hcm.mutable_common_http_protocol_options()->mutable_max_headers_count()->set_value(
+            max_count);
+      });
   max_request_headers_kb_ = max_size;
+  max_request_headers_count_ = max_count;
 
   Http::TestHeaderMapImpl big_headers{
       {":method", "GET"}, {":path", "/test/long/url"}, {":scheme", "http"}, {":authority", "host"}};
+  // Already added four headers.
+  for (unsigned int i = 0; i < count; i++) {
+    big_headers.addCopy(std::to_string(i), std::string(size * 1024, 'a'));
+  }
 
-  big_headers.addCopy("big", std::string(size * 1024, 'a'));
   initialize();
-
   codec_client_ = makeHttpConnection(lookupPort("http"));
-  if (size >= max_size) {
+  if (size >= max_size || count > max_count) {
     // header size includes keys too, so expect rejection when equal
     auto encoder_decoder = codec_client_->startRequest(big_headers);
     auto response = std::move(encoder_decoder.second);
@@ -928,8 +938,12 @@ void HttpIntegrationTest::testLargeRequestTrailers(uint32_t size, uint32_t max_s
 void HttpIntegrationTest::testManyRequestHeaders(std::chrono::milliseconds time) {
   config_helper_.addConfigModifier(
       [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)
-          -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });
+          -> void {
+        hcm.mutable_max_request_headers_kb()->set_value(96);
+        hcm.mutable_common_http_protocol_options()->mutable_max_headers_count()->set_value(20100);
+      });
   max_request_headers_kb_ = 96;
+  max_request_headers_count_ = 201000;
 
   Http::TestHeaderMapImpl big_headers{
       {":method", "GET"}, {":path", "/test/long/url"}, {":scheme", "http"}, {":authority", "host"}};
diff --git a/test/integration/http_integration.h b/test/integration/http_integration.h
index 7ad0fc519..8e2a7e7ec 100644
--- a/test/integration/http_integration.h
+++ b/test/integration/http_integration.h
@@ -176,7 +176,8 @@ protected:
   void testTwoRequests(bool force_network_backup = false);
   void testLargeHeaders(Http::TestHeaderMapImpl request_headers,
                         Http::TestHeaderMapImpl request_trailers, uint32_t size, uint32_t max_size);
-  void testLargeRequestHeaders(uint32_t size, uint32_t max_size = 60);
+  void testLargeRequestHeaders(uint32_t size, uint32_t count, uint32_t max_size = 60,
+                               uint32_t max_count = 100);
   void testLargeRequestTrailers(uint32_t size, uint32_t max_size = 60);
   void testManyRequestHeaders(std::chrono::milliseconds time = TestUtility::DefaultTimeout);
 
@@ -214,6 +215,7 @@ protected:
   // The codec type for the client-to-Envoy connection
   Http::CodecClient::Type downstream_protocol_{Http::CodecClient::Type::HTTP1};
   uint32_t max_request_headers_kb_{Http::DEFAULT_MAX_REQUEST_HEADERS_KB};
+  uint32_t max_request_headers_count_{Http::DEFAULT_MAX_HEADERS_COUNT};
   std::string access_log_name_;
 };
 } // namespace Envoy
diff --git a/test/integration/protocol_integration_test.cc b/test/integration/protocol_integration_test.cc
index 46b622aba..14fd62076 100644
--- a/test/integration/protocol_integration_test.cc
+++ b/test/integration/protocol_integration_test.cc
@@ -847,11 +847,84 @@ name: decode-headers-only
 }
 
 TEST_P(DownstreamProtocolIntegrationTest, LargeRequestHeadersRejected) {
-  testLargeRequestHeaders(95, 60);
+  // Send one 95 kB header with limit 60 kB and 100 headers.
+  testLargeRequestHeaders(95, 1, 60, 100);
 }
 
 TEST_P(DownstreamProtocolIntegrationTest, LargeRequestHeadersAccepted) {
-  testLargeRequestHeaders(95, 96);
+  // Send one 95 kB header with limit 96 kB and 100 headers.
+  testLargeRequestHeaders(95, 1, 96, 100);
+}
+
+TEST_P(DownstreamProtocolIntegrationTest, ManyRequestHeadersRejected) {
+  // Send 101 empty headers with limit 60 kB and 100 headers.
+  testLargeRequestHeaders(0, 101, 60, 80);
+}
+
+TEST_P(DownstreamProtocolIntegrationTest, ManyRequestHeadersAccepted) {
+  // Send 145 empty headers with limit 60 kB and 150 headers.
+  testLargeRequestHeaders(0, 140, 60, 150);
+}
+
+TEST_P(DownstreamProtocolIntegrationTest, ManyRequestTrailersRejected) {
+  // Default header (and trailer) count limit is 100.
+  Http::TestHeaderMapImpl request_trailers;
+  for (int i = 0; i < 150; i++) {
+    request_trailers.addCopy("trailer", std::string(1, 'a'));
+  }
+
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);
+  request_encoder_ = &encoder_decoder.first;
+  auto response = std::move(encoder_decoder.second);
+  codec_client_->sendData(*request_encoder_, 1, false);
+  codec_client_->sendTrailers(*request_encoder_, request_trailers);
+
+  // Only relevant to Http2Downstream.
+  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {
+    // Http1 Downstream ignores trailers.
+    waitForNextUpstreamRequest();
+    upstream_request_->encodeHeaders(default_response_headers_, true);
+    response->waitForEndStream();
+    EXPECT_TRUE(response->complete());
+    EXPECT_EQ("200", response->headers().Status()->value().getStringView());
+  } else {
+    // Expect rejection.
+    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));
+    response->waitForReset();
+    ASSERT_TRUE(fake_upstream_connection_->close());
+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());
+  }
+}
+
+TEST_P(DownstreamProtocolIntegrationTest, ManyRequestTrailersAccepted) {
+  // Set header (and trailer) count limit to 200.
+  uint32_t max_count = 200;
+  config_helper_.addConfigModifier(
+      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)
+          -> void {
+        hcm.mutable_common_http_protocol_options()->mutable_max_headers_count()->set_value(
+            max_count);
+      });
+  max_request_headers_count_ = max_count;
+  Http::TestHeaderMapImpl request_trailers;
+  for (int i = 0; i < 150; i++) {
+    request_trailers.addCopy("trailer", std::string(1, 'a'));
+  }
+
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);
+  request_encoder_ = &encoder_decoder.first;
+  auto response = std::move(encoder_decoder.second);
+  codec_client_->sendData(*request_encoder_, 1, false);
+  codec_client_->sendTrailers(*request_encoder_, request_trailers);
+  waitForNextUpstreamRequest();
+  upstream_request_->encodeHeaders(default_response_headers_, true);
+  response->waitForEndStream();
+  EXPECT_TRUE(response->complete());
+  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
 }
 
 TEST_P(DownstreamProtocolIntegrationTest, ManyRequestHeadersTimeout) {
@@ -870,7 +943,12 @@ TEST_P(DownstreamProtocolIntegrationTest, LargeRequestTrailersRejected) {
 TEST_P(DownstreamProtocolIntegrationTest, ManyTrailerHeaders) {
   config_helper_.addConfigModifier(
       [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)
-          -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });
+          -> void {
+        hcm.mutable_max_request_headers_kb()->set_value(96);
+        hcm.mutable_common_http_protocol_options()->mutable_max_headers_count()->set_value(20100);
+      });
+  max_request_headers_kb_ = 96;
+  max_request_headers_count_ = 201000;
 
   Http::TestHeaderMapImpl request_trailers{};
   for (int i = 0; i < 20000; i++) {
diff --git a/test/mocks/upstream/cluster_info.cc b/test/mocks/upstream/cluster_info.cc
index d34c8fa20..e6470093d 100644
--- a/test/mocks/upstream/cluster_info.cc
+++ b/test/mocks/upstream/cluster_info.cc
@@ -48,6 +48,8 @@ MockClusterInfo::MockClusterInfo()
   ON_CALL(*this, eds_service_name()).WillByDefault(ReturnPointee(&eds_service_name_));
   ON_CALL(*this, http2Settings()).WillByDefault(ReturnRef(http2_settings_));
   ON_CALL(*this, extensionProtocolOptions(_)).WillByDefault(Return(extension_protocol_options_));
+  ON_CALL(*this, maxResponseHeadersCount())
+      .WillByDefault(ReturnPointee(&max_response_headers_count_));
   ON_CALL(*this, maxRequestsPerConnection())
       .WillByDefault(ReturnPointee(&max_requests_per_connection_));
   ON_CALL(*this, stats()).WillByDefault(ReturnRef(stats_));
diff --git a/test/mocks/upstream/cluster_info.h b/test/mocks/upstream/cluster_info.h
index 46b318c3f..9b7f2f743 100644
--- a/test/mocks/upstream/cluster_info.h
+++ b/test/mocks/upstream/cluster_info.h
@@ -90,6 +90,7 @@ public:
   MOCK_CONST_METHOD0(lbOriginalDstConfig,
                      const absl::optional<envoy::api::v2::Cluster::OriginalDstLbConfig>&());
   MOCK_CONST_METHOD0(maintenanceMode, bool());
+  MOCK_CONST_METHOD0(maxResponseHeadersCount, uint32_t());
   MOCK_CONST_METHOD0(maxRequestsPerConnection, uint64_t());
   MOCK_CONST_METHOD0(name, const std::string&());
   MOCK_CONST_METHOD1(resourceManager, ResourceManager&(ResourcePriority priority));
@@ -111,6 +112,7 @@ public:
   Http::Http2Settings http2_settings_{};
   ProtocolOptionsConfigConstSharedPtr extension_protocol_options_;
   uint64_t max_requests_per_connection_{};
+  uint32_t max_response_headers_count_{Http::DEFAULT_MAX_HEADERS_COUNT};
   NiceMock<Stats::MockIsolatedStatsStore> stats_store_;
   ClusterStats stats_;
   Network::TransportSocketFactoryPtr transport_socket_factory_;
-- 
2.23.0.351.gc4317032e6-goog

